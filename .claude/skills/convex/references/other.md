# Convex - Other

**Pages:** 73

---

## Uploading and Storing Files

**URL:** https://docs.convex.dev/file-storage/upload-files

**Contents:**
- Uploading and Storing Files
- Uploading files via upload URLs​
  - Calling the upload APIs from a web page​
  - Generating the upload URL​
  - Writing the new storage ID to the database​
  - Limits​
- Uploading files via an HTTP action​
  - Calling the upload HTTP action from a web page​
  - Defining the upload HTTP action​

Upload files to Convex by generated upload urls, or via an custom HTTP Action.

Arbitrarily large files can be uploaded directly to your backend using a generated upload URL. This requires the client to make 3 requests:

In the first mutation that generates the upload URL you can control who can upload files to your Convex storage.

Example: File Storage with Queries and Mutations

Here's an example of uploading an image via a form submission handler to an upload URL generated by a mutation:

An upload URL can be generated by the storage.generateUploadUrl function of the MutationCtx object:

This mutation can control who is allowed to upload files.

The upload URL expires in 1 hour and so should be fetched shortly before the upload is made.

Since the storage ID is returned to the client it is likely you will want to persist it in the database via another mutation:

The file size is not limited, but upload POST request has a 2 minute timeout.

The file upload process can be more tightly controlled by leveraging HTTP actions, performing the whole upload flow using a single request, but requiring correct CORS headers configuration.

The custom upload HTTP action can control who can upload files to your Convex storage. But note that the HTTP action request size is currently limited to 20MB. For larger files you need to use upload URLs as described above.

Example: File Storage with HTTP Actions

Here's an example of uploading an image via a form submission handler to the sendImage HTTP action defined next.

The highlighted lines make the actual request to the HTTP action:

A file sent in the HTTP request body can be stored using the storage.store function of the ActionCtx object. This function returns an Id<"_storage"> of the stored file.

From the HTTP action you can call a mutation to write the storage ID to a document in your database.

To confirm success back to your hosted website, you will need to set the right CORS headers:

You also need to handle the pre-flight OPTIONS request:

**Examples:**

Example 1 (tsx):
```tsx
import { FormEvent, useRef, useState } from "react";import { useMutation } from "convex/react";import { api } from "../convex/_generated/api";export default function App() {  const generateUploadUrl = useMutation(api.messages.generateUploadUrl);  const sendImage = useMutation(api.messages.sendImage);  const imageInput = useRef<HTMLInputElement>(null);  const [selectedImage, setSelectedImage] = useState<File | null>(null);  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));  async function handleSendImage(event: FormEvent) {    event.preventDefault();    // Step 1: Get a short-lived upload URL    const postUrl = await generateUploadUrl();    // Step 2: POST the file to the URL    const result = await fetch(postUrl, {      method: "POST",      headers: { "Content-Type": selectedImage!.type },      body: selectedImage,    });    const { storageId } = await result.json();    // Step 3: Save the newly allocated storage id to the database    await sendImage({ storageId, author: name });    setSelectedImage(null);    imageInput.current!.value = "";  }  return (    <form onSubmit={handleSendImage}>      <input        type="file"        accept="image/*"        ref={imageInput}        onChange={(event) => setSelectedImage(event.target.files![0])}        disabled={selectedImage !== null}      />      <input        type="submit"        value="Send Image"        disabled={selectedImage === null}      />    </form>  );}
```

Example 2 (ts):
```ts
import { mutation } from "./_generated/server";export const generateUploadUrl = mutation({  handler: async (ctx) => {    return await ctx.storage.generateUploadUrl();  },});
```

Example 3 (ts):
```ts
import { mutation } from "./_generated/server";export const sendImage = mutation({  args: { storageId: v.id("_storage"), author: v.string() },  handler: async (ctx, args) => {    await ctx.db.insert("messages", {      body: args.storageId,      author: args.author,      format: "image",    });  },});
```

Example 4 (tsx):
```tsx
import { FormEvent, useRef, useState } from "react";const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;export default function App() {  const imageInput = useRef<HTMLInputElement>(null);  const [selectedImage, setSelectedImage] = useState<File | null>(null);  async function handleSendImage(event: FormEvent) {    event.preventDefault();    // e.g. https://happy-animal-123.convex.site/sendImage?author=User+123    const sendImageUrl = new URL(`${convexSiteUrl}/sendImage`);    sendImageUrl.searchParams.set("author", "Jack Smith");    await fetch(sendImageUrl, {      method: "POST",      headers: { "Content-Type": selectedImage!.type },      body: selectedImage,    });    setSelectedImage(null);    imageInput.current!.value = "";  }  return (    <form onSubmit={handleSendImage}>      <input        type="file"        accept="image/*"        ref={imageInput}        onChange={(event) => setSelectedImage(event.target.files![0])}        disabled={selectedImage !== null}      />      <input        type="submit"        value="Send Image"        disabled={selectedImage === null}      />    </form>  );}
```

---

## Application Errors

**URL:** https://docs.convex.dev/functions/error-handling/application-errors

**Contents:**
- Application Errors
- Returning different values​
- Throwing application errors​
  - Application error data payload​
- Handling application errors on the client​

If you have expected ways your functions might fail, you can either return different values or throw ConvexErrors.

If you're using TypeScript different return types can enforce that you're handling error scenarios.

For example, a createUser mutation could return

to express that either the mutation succeeded or the email address was already taken.

This ensures that you remember to handle these cases in your UI.

You might prefer to throw errors for the following reasons:

Convex provides an error subclass, ConvexError, which can be used to carry information from the backend to the client:

You can pass the same data types supported by function arguments, return types and the database, to the ConvexError constructor. This data will be stored on the data property of the error:

Error payloads more complicated than a simple string are helpful for more structured error logging, or for handling sets of errors differently on the client.

On the client, application errors also use the ConvexError class, and the data they carry can be accessed via the data property:

**Examples:**

Example 1 (ts):
```ts
Id<"users"> | { error: "EMAIL_ADDRESS_IN_USE" };
```

Example 2 (ts):
```ts
import { ConvexError } from "convex/values";import { mutation } from "./_generated/server";export const assignRole = mutation({  args: {    // ...  },  handler: (ctx, args) => {    const isTaken = isRoleTaken(/* ... */);    if (isTaken) {      throw new ConvexError("Role is already taken");    }    // ...  },});
```

Example 3 (ts):
```ts
// error.data === "My fancy error message"throw new ConvexError("My fancy error message");// error.data === {message: "My fancy error message", code: 123, severity: "high"}throw new ConvexError({  message: "My fancy error message",  code: 123,  severity: "high",});// error.data === {code: 123, severity: "high"}throw new ConvexError({  code: 123,  severity: "high",});
```

Example 4 (tsx):
```tsx
import { ConvexError } from "convex/values";import { useMutation } from "convex/react";import { api } from "../convex/_generated/api";export function MyApp() {  const doSomething = useMutation(api.myFunctions.mutateSomething);  const handleSomething = async () => {    try {      await doSomething({ a: 1, b: 2 });    } catch (error) {      const errorMessage =        // Check whether the error is an application error        error instanceof ConvexError          ? // Access data and cast it to the type we expect            (error.data as { message: string }).message          : // Must be some developer error,            // and prod deployments will not            // reveal any more information about it            // to the client            "Unexpected error occurred";      // do something with `errorMessage`    }  };  // ...}
```

---

## Data Types

**URL:** https://docs.convex.dev/using/types

**Contents:**
- Data Types
- Convex values​
- System fields​
- Limits​
- Working with undefined​
- Working with dates and times​

All Convex documents are defined as Javascript objects. These objects can have field values of any of the types below.

You can codify the shape of documents within your tables by defining a schema.

Convex supports the following types of values:

Every document in Convex has two automatically-generated system fields:

Convex values must be less than 1MB in total size. This is an approximate limit for now, but if you're running into these limits and would like a more precise method to calculate a document's size, reach out to us. Documents can have nested values, either objects or arrays that contain other Convex types. Convex types can have at most 16 levels of nesting, and the cumulative size of a nested tree of values must be under the 1MB limit.

Table names may contain alphanumeric characters ("a" to "z", "A" to "Z", and "0" to "9") and underscores ("_"), and they cannot start with an underscore.

For information on other limits, see here.

If any of these limits don't work for you, let us know!

The TypeScript value undefined is not a valid Convex value, so it cannot be used in Convex function arguments or return values, or in stored documents.

If you would prefer to avoid the special behaviors of undefined, you can use null instead, which is a valid Convex value.

Convex does not have a special data type for working with dates and times. How you store dates depends on the needs of your application:

For more sophisticated printing (formatting) and manipulation of dates and times use one of the popular JavaScript libraries: date-fns, Day.js, Luxon or Moment.js.

**Examples:**

Example 1 (ts):
```ts
if (args.a === null) {  args.a = undefined;}await ctx.db.patch(id, args);
```

---

## Convex & Auth0

**URL:** https://docs.convex.dev/auth/auth0

**Contents:**
- Convex & Auth0
- Get started​
- Login and logout flows​
- Logged-in and logged-out views​
- User information in React​
- User information in functions​
- Configuring dev and prod tenants​
  - Configuring the backend​
  - Configuring a React client​
- Debugging authentication​

Auth0 is an authentication platform providing login via passwords, social identity providers, one-time email or SMS access codes, multi-factor authentication, and single sign on and basic user management.

Example: Convex Authentication with Auth0

If you're using Next.js see the Next.js setup guide.

This guide assumes you already have a working React app with Convex. If not follow the Convex React Quickstart first. Then:

Follow the Auth0 React Quickstart.

Sign up for a free Auth0 account.

Configure your application, using http://localhost:3000, http://localhost:5173 for Callback and Logout URLs and Allowed Web Origins.

Come back when you finish the Install the Auth0 React SDK step.

In the convex folder create a new file auth.config.ts with the server-side configuration for validating access tokens.

Paste in the domain and clientId values shown in Install the Auth0 React SDK step of the Auth0 quickstart or in your Auth0 application's Settings dashboard.

Run npx convex dev to automatically sync your configuration to your backend.

Now replace your ConvexProvider with an Auth0Provider wrapping ConvexProviderWithAuth0. Add the domain and clientId as props to the Auth0Provider.

Paste in the domain and clientId values shown in Install the Auth0 React SDK step of the Auth0 quickstart or in your Auth0 application's Settings dashboard as props to Auth0Provider.

Now that you have everything set up, you can use the useAuth0() hook to create login and logout buttons for your app.

The login button will redirect the user to the Auth0 universal login page. For details see Add Login to Your Application in the Auth0 React Quickstart.

The logout button will redirect the user to the Auth0 logout endpoint. For details see Add Logout to your Application in the Auth0 React Quickstart.

Use the useConvexAuth() hook instead of the useAuth0 hook when you need to check whether the user is logged in or not. The useConvex hook makes sure that the browser has fetched the auth token needed to make authenticated requests to your Convex backend:

You can also use the Authenticated, Unauthenticated and AuthLoading helper components which use the useConvexAuth hook under the hood:

You can access information about the authenticated user like their name from the useAuth0 hook:

See Auth in Functions to learn about how to access information about the authenticated user in your queries, mutations and actions.

See Storing Users in the Convex Database to learn about how to store user information in the Convex database.

To configure a different Auth0 tenant (environment) between your Convex development and production deployments you can use environment variables configured on the Convex dashboard.

First, change your auth.config.ts file to use environment variables:

Development configuration

Open the Settings for your dev deployment on the Convex dashboard and add the variables there:

Now switch to the new configuration by running npx convex dev.

Production configuration

Similarly on the Convex dashboard switch to your production deployment in the left side menu and set the values for your production Auth0 tenant there.

Now switch to the new configuration by running npx convex deploy.

To configure your client you can use environment variables as well. The exact name of the environment variables and the way to refer to them depends on each client platform (Vite vs Next.js etc.), refer to our corresponding Quickstart or the relevant documentation for the platform you're using.

Change the props to Auth0Provider to take in environment variables:

Development configuration

Use the .env.local or .env file to configure your client when running locally. The name of the environment variables file depends on each client platform (Vite vs Next.js etc.), refer to our corresponding Quickstart or the relevant documentation for the platform you're using:

Production configuration

Set the environment variables in your production environment depending on your hosting platform. See Hosting.

If a user goes through the Auth0 login flow successfully, and after being redirected back to your page useConvexAuth gives isAuthenticated: false, it's possible that your backend isn't correctly configured.

The auth.config.ts file in your convex/ directory contains a list of configured authentication providers. You must run npx convex dev or npx convex deploy after adding a new provider to sync the configuration to your backend.

For more thorough debugging steps, see Debugging Authentication.

The authentication flow looks like this under the hood:

ConvexProviderWithAuth0 takes care of refetching the token when needed to make sure the user stays authenticated with your backend.

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      domain: "your-domain.us.auth0.com",      applicationID: "yourclientid",    },  ]} satisfies AuthConfig;
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (tsx):
```tsx
import React from "react";import ReactDOM from "react-dom/client";import App from "./App";import "./index.css";import { ConvexReactClient } from "convex/react";import { ConvexProviderWithAuth0 } from "convex/react-auth0";import { Auth0Provider } from "@auth0/auth0-react";const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);ReactDOM.createRoot(document.getElementById("root")!).render(  <React.StrictMode>    <Auth0Provider      domain="your-domain.us.auth0.com"      clientId="yourclientid"      authorizationParams={{        redirect_uri: window.location.origin,      }}      useRefreshTokens={true}      cacheLocation="localstorage"    >      <ConvexProviderWithAuth0 client={convex}>        <App />      </ConvexProviderWithAuth0>    </Auth0Provider>  </React.StrictMode>,);
```

Example 4 (tsx):
```tsx
import { useAuth0 } from "@auth0/auth0-react";export default function LoginButton() {  const { loginWithRedirect } = useAuth0();  return <button onClick={loginWithRedirect}>Log in</button>;}
```

---

## Automatic AuthKit Configuration

**URL:** https://docs.convex.dev/auth/authkit/auto-provision

**Contents:**
- Automatic AuthKit Configuration
- Creating WorkOS environments on-demand​
  - Limitations​

AuthKit configuration can be automated for cloud dev deployments: each Convex deployment gets its own WorkOS environment configured and has local environment variables added to .env.local and Convex deployment environment variables set for it.

This integration is in active development and will change as it continues to improve. Today the integration works with the two AuthKit templates offered when running npm create convex@latest.

Automatically provisioning a WorkOS environment for a Convex deployment is enabled by creating a new WorkOS account and team to associate with a Convex team. Once this account has been created, any member of the Convex team can create a WorkOS environment for their development deployments on each of the team's projects.

This happens automatically whenever the WORKOS_CLIENT_ID environment variable is read in the convex/auth.config.ts file but not set on the deployment during a convex dev.

The CLI then makes AuthKit-related configuration changes that replace the manual configuration steps required to configure AuthKit for a development Convex deployment.

Currently this configures the following with the assumed local development domain:

The following local environment variables may be set in .env.local:

WorkOS environments can currently only be created for cloud development deployments. Preview and production deployments must be manually configured.

To manually configure the production deployment, visit the WorkOS page for the production environment for this project and follow these steps. Only one production deployment exists by default per WorkOS team so additional project may need to use separate WorkOS teams.

---

## History

**URL:** https://docs.convex.dev/dashboard/deployments/history

**Contents:**
- History

The history page is only available on Convex Professional.

This history page is an audit log of configuration-related events that have occurred in the selected deployment, such as function deployments, changes to indexes, and changes to environment variables.

You may also view an audit log of team-related events in the team audit log.

---

## Internal Functions

**URL:** https://docs.convex.dev/functions/internal-functions

**Contents:**
- Internal Functions
- Use cases for internal functions​
- Defining internal functions​
- Calling internal functions​

Internal functions can only be called by other functions and cannot be called directly from a Convex client.

By default your Convex functions are public and accessible to clients. Public functions may be called by malicious users in ways that cause surprising results. Internal functions help you mitigate this risk. We recommend using internal functions any time you're writing logic that should not be called from a client.

While internal functions help mitigate risk by reducing the public surface area of your application, you can still validate internal invariants using argument validation and/or authentication.

Leverage internal functions by:

An internal function is defined using internalQuery, internalMutation, or internalAction. For example:

If you need to pass complicated objects to internal functions you might prefer to not use argument validation. Note though that if you're using internalQuery or internalMutation it's a better idea to pass around document IDs instead of documents, to ensure the query or mutation is working with the up-to-date state of the database.

Internal functions can be called from actions and scheduled from actions and mutation using the internal object.

For example, consider this public upgrade action that calls the internal plans.markPlanAsProfessional mutation we defined above:

In this example a user should not be able to directly call internal.plans.markPlanAsProfessional without going through the upgrade action — if they did, then they would get a free upgrade.

You can define public and internal functions in the same file.

**Examples:**

Example 1 (ts):
```ts
import { internalMutation } from "./_generated/server";import { v } from "convex/values";export const markPlanAsProfessional = internalMutation({  args: { planId: v.id("plans") },  handler: async (ctx, args) => {    await ctx.db.patch(args.planId, { planType: "professional" });  },});
```

Example 2 (ts):
```ts
import { internalAction } from "./_generated/server";import { Doc } from "./_generated/dataModel";export const markPlanAsProfessional = internalAction({  handler: async (actionCtx, args) => {    // perform an action, perhaps calling a third-party API  },});
```

Example 3 (ts):
```ts
import { action } from "./_generated/server";import { internal } from "./_generated/api";import { v } from "convex/values";export const upgrade = action({  args: {    planId: v.id("plans"),  },  handler: async (ctx, args) => {    // Call out to payment provider (e.g. Stripe) to charge customer    const response = await fetch("https://...");    if (response.ok) {      // Mark the plan as "professional" in the Convex DB      await ctx.runMutation(internal.plans.markPlanAsProfessional, {        planId: args.planId,      });    }  },});
```

---

## CLI

**URL:** https://docs.convex.dev/cli

**Contents:**
- CLI
- Configure​
  - Create a new project​
  - Recreate project configuration​
  - Log out​
- Develop​
  - Run the Convex dev server​
  - Open the dashboard​
  - Open the docs​
  - Run Convex functions​

The Convex command-line interface (CLI) is your interface for managing Convex projects and Convex functions.

To install the CLI, run:

You can view the full list of commands with:

The first time you run

it will ask you to log in your device and create a new Convex project. It will then create:

in a project directory without a set CONVEX_DEPLOYMENT to configure a new or existing project.

Remove the existing Convex credentials from your device, so subsequent commands like npx convex dev can use a different Convex account.

Watches the local filesystem. When you change a function or the schema, the new versions are pushed to your dev deployment and the generated types in convex/_generated are updated. By default, logs from your dev deployment are displayed in the terminal.

It's also possible to run a Convex deployment locally for development.

Open the Convex dashboard.

Get back to these docs!

Run a public or internal Convex query, mutation, or action on your development deployment.

Arguments are specified as a JSON object.

Add --watch to live update the results of a query. Add --push to push local code to the deployment before running the function.

Use --prod to run functions in the production deployment for a project.

You can choose how to pipe logs from your dev deployment to your console:

Use --prod with npx convex logs to tail the prod deployment logs instead.

See description and use-cases: data import.

See description and use-cases: data export.

Display a simple view of the dashboard data page in the command line.

The command supports --limit and --order flags to change data displayed. For more complex filters, use the dashboard data page or write a query.

The npx convex data <table> command works with system tables, such as _storage, in addition to your own tables.

See and update the deployment environment variables which you can otherwise manage on the dashboard environment variables settings page.

The target deployment to push to is determined like this:

Once this command succeeds the new functions will be available immediately.

When run with the CONVEX_DEPLOY_KEY environment variable containing a Preview Deploy Key, this command will:

Create a new Convex deployment. npx convex deploy will infer the Git branch name for Vercel, Netlify, GitHub, and GitLab environments, or the --preview-create option can be used to customize the name associated with the newly created deployment.

Run a command if specified with --cmd. The command will have CONVEX_URL (or similar) environment variable available:

You can customize the URL environment variable name with --cmd-url-env-var-name:

Typecheck your Convex functions.

Regenerate the generated code in the convex/_generated directory.

Bundle your Convex functions and their dependencies.

Push your functions, indexes, and schema to the deployment.

Run a function specified by --preview-run (similar to the --run option for npx convex dev).

See the Vercel or Netlify hosting guide for setting up frontend and backend previews together.

The generated code in the convex/_generated directory includes types required for a TypeScript typecheck. This code is generated whenever necessary while running npx convex dev and this code should be committed to the repo (your code won't typecheck without it!).

In the rare cases it's useful to regenerate code (e.g. in CI to ensure that the correct code was checked it) you can use this command.

Generating code can require communicating with a convex deployment in order to evaluate configuration files in the Convex JavaScript runtime. This doesn't modify the code running on the deployment.

**Examples:**

Example 1 (sh):
```sh
npm install convex
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (sh):
```sh
npx convex dev
```

Example 4 (sh):
```sh
npx convex logout
```

---

## File Storage

**URL:** https://docs.convex.dev/dashboard/deployments/file-storage

**Contents:**
- File Storage

The file storage page displays files stored in your deployment. The page also shows the files' storage IDs, size, and content type. You can upload new files and download or delete existing files.

Storage IDs might be referenced by documents in your database.

When new files are uploaded, the UI will reference the name of the recently uploaded file. However, these names are not persisted and will no longer appear when the page is reloaded.

---

## Data

**URL:** https://docs.convex.dev/dashboard/deployments/data

**Contents:**
- Data
- Filtering documents​
- Writing custom queries​
- Creating tables​
- Creating documents​
- Quick actions (context menu)​
- Editing a cell​
- Editing a document​
- Adding references to other documents​
- Bulk editing documents​

The data page allows you to view and manage all of your tables and documents.

On the left side of the page is a list of your tables. Clicking on a table will allows you to create, view, update, and delete documents in that table.

You may drag-and-drop the column headers in each table to visually re-order the data.

A readonly view of the data page is available in the command line.

You may filters documents on the data page by clicking the "Filter" button on the top of the page.

All fields in a document are filterable by the operations supported in Convex query syntax. Equality and comparisons share the same rules when filtering in the dashboard as a query using the Convex client. You may also filter based on the type of the field.

To add a filter, click the + next to an existing filter. If you add more than one condition, they will be evaluated using the and operation.

For each filter, you must select a field to filter by, operation, and comparison value. In the third input box (selecting a value), you may enter a valid Convex value, such as "a string", 123, or even a complex object, such as { a: { b: 2 } }

When filtering by _creationTime, a date picker will be displayed instead of the normal JavaScript syntax input box. Comparisons for _creationTime are made at the nanosecond granularity, so if you'd like to filter to an exact time, try adding two filter conditions for creationTime >= $time and creationTime <= $time + 1 minute.

You can write a query directly in the dashboard. This allows you to perform arbitrary filtering and transformation of the data, including sorting, joins, grouping and aggregations.

In the ⋮ overflow menu at the top of the data page click on the “Custom query” option.

This opens the same UI used for running your deployed functions, but with the “Custom test query” option selected, which lets you edit the source code for the query. This source code will be sent to your deployment and executed when you click on the “Run Custom Query“ button.

If you're not on the data page, you can still open this UI via the persistent fn button shown on the bottom right of all deployment pages. The keyboard shortcut to open the function runner is Ctrl + ` (backtick).

You may create a table from the dashboard by clicking the "Create Table" button and entering a new name for the table.

You may add individual documents to the table using the “Add Documents” button located in the data table's toolbar.

Once you click “Add Documents” a side panel will open, allowing you to add new documents to your table using JavaScript syntax. To add more than one document add a time, add new objects to the array in the editor.

You can right-click on a document or value to open a context menu with quick actions, like copying values, quickly filtering by the selected value, and deleting documents.

To edit a cell's value, double-click on the cell in the data table, or press the Enter key while it’s selected. You can change the selected cell by using the arrow keys.

You can change the value by editing inline, and pressing enter to save.

You can even edit the type of your value here, as long as it satisfies your schema — try replacing a string with an object!

To edit multiple fields in a document at the same time, hover over the document and right-click to open the context menu. From there you can click on "Edit Document".

To reference another document, use the string ID of the document you want to reference.

You can copy the ID by clicking on its cell and pressing CTRL/CMD+C.

You can edit multiple or all documents at once. To select all documents click on the checkbox in the table header row. To select individual documents hover over the left-most cell and click the checkbox that appears. To select multiple adjacent documents at once, press the Shift key when clicking on the checkbox.

When at least one document is selected, the “(Bulk) Edit Document(s)” button will be visible in the table toolbar. Click the button and an editor will appear on the right hand side.

When at least one document is selected (see above), the “Delete Document(s)” button will be visible in the table toolbar. Click the button to delete documents. If you're editing data in a production deployment a confirmation dialog will appear before the documents are deleted.

You can also delete all documents by clicking on the ⋮ overflow menu at the top of the data page and clicking "Clear Table". This action will delete all documents in the table, without deleting the table itself.

In production environments, the Convex dashboard will have you type in the name of the table before deletion.

Deleting a table is irreversible. In production environments, the Convex dashboard will have you type in the name of the table before deletion.

The "Delete table" button can be found by clicking on the ⋮ overflow menu at the top of the data page. This action will delete all documents this table, and remove the table from your list of tables. If this table had indexes, you will need to redeploy your convex functions (by running npx convex deploy or npx convex dev for production or development, respectively) to recreate the indexes.

At the bottom-left of the page is a "Generate Schema" button which you can click to have Convex generate a schema of all your documents within this table.

The "Schema" button can be found by clicking on the ⋮ overflow menu at the top of the data page.

This button will open a panel showing the saved and generated schemas associated with the selected table.

The "Indexes" button can be found by clicking on the ⋮ overflow menu at the top of the data page.

This button will open a panel showing the indexes associated with the selected table.

Indexes that have not completed backfilling will be accompanied by a loading spinner next to their name.

**Examples:**

Example 1 (sh):
```sh
npx convex data [table]
```

---

## Testing

**URL:** https://docs.convex.dev/testing

**Contents:**
- Testing
- Automated tests​
  - convex-test library​
  - Testing against a real backend​
  - Set up testing in CI​
- Manual tests​
  - Running a function in dev​
  - Preview deployments​
  - Staging environment​

Convex makes it easy to test your app via automated tests running in JS or against a real backend, and manually in dev, preview and staging environments.

Use the convex-test library to test your functions in JS via the excellent Vitest testing framework.

Convex open source builds allow you to test all of your backend logic running on a real local Convex backend.

It's a good idea to test your app continuously in a controlled environment. No matter which way automated method you use, it's easy to run them with GitHub Actions.

Manually run a function in dev to quickly see if things are working:

Use preview deployments to get early feedback from your team for your in-progress features.

You can set up a separate project as a staging environment to test against. See Deploying Your App to Production.

---

## Convex Overview

**URL:** https://docs.convex.dev/understanding

**Contents:**
- Convex Overview
- Database​
- Server functions​
- Client libraries​
- Putting it all together​
- Beyond reactivity​
- For human and AI generated code​
- Learn more​

Convex is the open source, reactive database where queries are TypeScript code running right in the database. Just like React components react to state changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client libraries. It makes it easy to build and scale dynamic live-updating apps.

The following diagram shows the standard three-tier app architecture that Convex enables. We'll start at the bottom and work our way up to the top of this diagram.

The database is at the core of Convex. The Convex database is automatically provisioned when you create your project. There is no connection setup or cluster management.

In Convex, your database queries are just TypeScript code written in your server functions. There is no SQL to write. There are no ORMs needed.

The Convex database is reactive. Whenever any data on which a query depends changes, the query is rerun, and client subscriptions are updated.

Convex is a "document-relational" database. "Document" means you put JSON-like nested objects into your database. "Relational" means you have tables with relations, like tasks assigned to a user using IDs to reference documents in other tables.

The Convex cloud offering runs on top of Amazon RDS using MySQL as its persistence layer. The Open Source version uses SQLite, Postgres and MySQL. The database is ACID-compliant and uses serializable isolation and optimistic concurrency control. All that to say, Convex provides the strictest possible transactional guarantees, and you never see inconsistent data.

When you create a new Convex project, you automatically get a convex/ folder where you write your server functions. This is where all your backend application logic and database query code live.

Example TypeScript server functions that read (query) and write (mutation) to the database.

You read and write to your database through query or mutation functions. Query functions are pure functions that can only read from the database. Mutation functions are transactions that can read or write from the database. These two database functions are not allowed to take any non-deterministic actions like network requests to ensure transactional guarantees.

The entire Convex mutation function is a transaction. There are no begin or end transaction statements to write. Convex automatically retries the function on conflicts, and you don't have to manage anything.

Convex also provides standard general-purpose serverless functions called actions. Action functions can make network requests. They have to call query or mutation functions to read and write to the database. You use actions to call LLMs or send emails.

You can also durably schedule Convex functions via the scheduler or cron jobs. Scheduling lets you build workflows like emailing a new user a day later if they haven't performed an onboarding task.

You call your Convex functions via client libraries or directly via HTTP.

Convex client libraries keep your frontend synced with the results of your server functions.

Like the useState hook that updates your React component when local state changes, the Convex useQuery hook automatically updates your component whenever the result of your query changes. There's no manual subscription management or state synchronization needed.

When calling query functions, the client library subscribes to the results of the function. Convex tracks the dependencies of your query functions, including what data was read from the database. Whenever relevant data in the database changes, the Convex automatically reruns the query and sends the result to the client.

The client library also queues up mutations in memory to send to the server. As mutations execute and cause query results to update, the client library keeps your app state consistent. It updates all subscriptions to the same logical moment in time in the database.

Convex provides client libraries for nearly all popular web and native app frameworks. Client libraries connect to your Convex deployment via WebSockets. You can then call your public Convex functions through the library. You can also use Convex with HTTP directly, you just won't get the automatic subscriptions.

Let's return to the getAllOpenTasks Convex query function from earlier that gets all tasks that are not marked as completed:

Let's follow along what happens when you subscribe to this query:

The web app uses the useQuery hook to subscribe to this query, and the following happens to get an initial value:

In this case the initial result looks like this (1):

Then you use a mutation to mark an item as completed (2). Convex then reruns the query (3) to get an updated result. And pushes the result to the web app via the WebSocket connection (4):

Beyond reactivity, Convex's architecture is crucial for a deeper reason. Convex does not let your app have inconsistent state at any layer of the stack.

To illustrate this, let's imagine you're building a shopping cart for an e-commerce store.

On the product listing page, you have two numbers, one showing the number of items remaining in stock and another showing the number of items in your shopping cart. Each number is a result of a different query function.

Every time you press the "Add to Cart" button, a mutation is called to remove one item from the stock and add it to the shopping cart.

The mutation to change the cart runs in a transaction, so your database is always in a consistent state. The reactive database knows that the queries showing the number of items in stock and the number of items in the shopping cart both need to be updated. The queries are invalidated and rerun. The results are pushed to the web app via the WebSocket connection.

The client library makes sure that both queries update at the same time in the web app since they reflect a singular moment in time in your database. You never have a moment where those numbers don't add up. Your app always shows consistent data.

You can see this example in action in the Swaghaus sample app.

Convex is designed around a small set of composable abstractions with strong guarantees that result in code that is not only faster to write, it’s easier to read and maintain, whether written by a team member or an LLM. Key features make sure you get bug-free AI generated code:

Together, these features mean AI can focus on your business logic while Convex's guarantees prevent common failure modes.

If you are intrigued about the details of how Convex pulls this all off, you can read Convex co-founder Sujay's excellent How Convex Works blog post.

Now that you have a good sense of how Convex fits in your app. Let's walk through the overall workflow of setting up and launching a Convex app.

**Examples:**

Example 1 (typescript):
```typescript
// A Convex query functionexport const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});// A Convex mutation functionexport const setTaskCompleted = mutation({  args: { taskId: v.id("tasks"), completed: v.boolean() },  handler: async (ctx, { taskId, completed }) => {    // Update the database using TypeScript    await ctx.db.patch(taskId, { completed });  },});
```

Example 2 (tsx):
```tsx
// In your React componentimport { useQuery } from "convex/react";import { api } from "../convex/_generated/api";export function TaskList() {  const data = useQuery(api.tasks.getAllOpenTasks);  return data ?? "Loading...";}
```

Example 3 (typescript):
```typescript
export const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});
```

Example 4 (json):
```json
[  { _id: "e4g", title: "Grocery shopping", complete: false },  { _id: "u9v", title: "Plant new flowers", complete: false },];
```

---

## Agent Mode

**URL:** https://docs.convex.dev/cli/agent-mode

**Contents:**
- Agent Mode

When logged in on your own machine, agents like Cursor and Claude Code can run CLI commands like npx convex env list that use your logged-in credentials run commands against your personal dev environment as if you ran the commands yourself. This works well when you're collaborating with an agent; just like when the agent runs git commit -am "Fix.", the commit will use your local git credentials.

But when cloud-based coding agents like Jules, Devin, Codex, or Cursor background agents run Convex CLI commands, they can't log in. And if you do log in for them, the agent will use your default dev deployment to develop, conflicting with your own changes!

Instead, set CONVEX_AGENT_MODE=anonymous in this environment, causing the agent to use anonymous development to run a separate Convex backend on the VM where the agent is working.

Convex Agent Mode is currently a beta feature. If you have feedback or feature requests, let us know on Discord!

You can set this variable in .env.local or set it in the agent's environment.

In the future CONVEX_AGENT_MODE may support other behaviors like allowing agents to provision their own short-lived cloud deployments.

**Examples:**

Example 1 (text):
```text
CONVEX_AGENT_MODE=anonymous npx convex dev
```

---

## Functions

**URL:** https://docs.convex.dev/dashboard/deployments/functions

**Contents:**
- Functions
- Running functions​
  - Querying a paginated function​
  - Assuming a user identity​
- Metrics​
  - Invocations​
  - Errors​
  - Cache Hit Rate​
  - Execution Time​

The functions page shows all currently deployed Convex functions.

For dev deployments, these are updated continuously by npx convex dev. The functions for production deployments are registered with npx convex deploy.

To run a Convex function in the dashboard, select a function from the list on the left-hand side of the page, and click the "Run Function" button that appears next to the function's name.

If you're not on the functions page, you can still open this UI via the persistent fn button shown on the bottom right of all deployment pages. The keyboard shortcut to open the function runner is Ctrl + ` (backtick).

This view allows you to fill out the arguments for your function and run it.

Query results will update automatically as you modify function arguments and data changes.

Mutation and action results will be visible once you click the "Run" button.

Note that these results will show the logs and value returned from the function. To see what changed when you ran your function, see the data page.

You can also write a custom query function by choosing the “Custom test query“ option instead of one of your deployed functions.

When querying a paginated function in the dashboard, the UI will expect the arguments to include PaginationOptions -- i.e. an object containing the numItems field, and optionally the cursor field. The name of this argument should be the same as the name defined in your query function.

Assuming a user identity in the Convex dashboard does not give you access to a real user identity. Instead, this concept can be thought of as "mocking" a user identity into your function.

If you're building an authenticated application, you may want to run a Convex function while acting as an authenticated user identity.

To do so, check the "Act as a user" box.

From there, you can type in the box that appears to fill out the user identity object.

The valid user attributes are:

*These attributes are required.

There are four basic charts for each function. For overall team usage metrics, see team settings.

This chart plots the number of times your function was called per minute. As your app's usage increases, you should see this chart trend upward as well.

A plot of any exceptions that occur while running your function. Want to know what's going wrong? Check out the logs page, detailed below.

Cache hit rate only applies to query functions

A percentage rate of how often this function is simply reusing a cached value vs. being rerun. Your application will run best and your response times will be fastest with high cache hit rates.

How long, in milliseconds, this function is taking to run.

There are four individual lines plotted on this chart, p50, p90, p95, and p99. Each of these lines represents the response time for that percentile in the distribution of hits over time. So, only 1% of requests took longer to run than the time shown by the p99 line. Typically, keeping an eye on these tail latencies is a good way to make sure your application is getting data services quickly.

Consider the relationship of the execution time to the cache hit rate. As a rule, a cache hit takes well under 1 ms, so the higher your cache hit rate, the better your response times will be.

Clicking on any of the charts will give you a larger, detailed view where you can customize the time ranges you're inspecting.

---

## Deleting Files

**URL:** https://docs.convex.dev/file-storage/delete-files

**Contents:**
- Deleting Files

Files stored in Convex can be deleted from mutations, actions, and HTTP actions via the storage.delete() function, which accepts a storage ID.

Storage IDs correspond to documents in the "_storage" system table (see Metadata), so they can be validated using the v.id("_storage").

**Examples:**

Example 1 (ts):
```ts
import { v } from "convex/values";import { Id } from "./_generated/dataModel";import { mutation } from "./_generated/server";export const deleteById = mutation({  args: {    storageId: v.id("_storage"),  },  handler: async (ctx, args) => {    return await ctx.storage.delete(args.storageId);  },});
```

---

## Teams

**URL:** https://docs.convex.dev/dashboard/teams

**Contents:**
- Teams
- General​
- Team Members​
  - Roles and permissions​
    - Team roles​
    - Project Admins​
- Billing​
  - Spending limits​
- Usage​
- Audit Log​

In Convex, your projects are organized by team. Teams are used to share access to your projects with other people. You may switch between teams or create a new team by clicking on the name of your team located on the top of the Convex dashboard. This will open the project selector, where you can switch teams by clicking on the team name once again.

You may change the name of a team or invite new members to a team by clicking on the "Team Settings" button located on the top of the project list page.

The general page allows changing the team name and slug.

You may also delete the team from this page. You can only delete a team after deleting all of it's projects, and removing all other team members from your team. Deleting your team will automatically cancel your Convex subscription.

Use the members settings page to invite or remove members from your team.

Convex has two levels of control for managing access to your team, projects, and deployments. Team-level roles control what a user can do within the team, while project-level permissions control what a user can do within a specific project.

Your team members can have one of the following roles:

The creator of the team is automatically assigned the Admin role. When inviting new team members, you may select a role for them. You may also change the role of a team member at any time.

Admins can do everything developers can, as well as:

In addition to team roles, you may also grant admin access to individual projects by granting team members the "Project Admin" role.

If you are a Project Admin for a given project, you may:

You may assign and remove the Project Admin role for multiple projects at the same time on the member settings page. To assign or remove the Project Admin role for multiple members at the same time, visit the Project Settings page instead.

Use the billing page to upgrade your Convex subscription to a higher tier, or manage your existing subscription.

On paid plans, you can also update your billing contact details, payment method, and view your invoices.

Learn more about Convex pricing.

When you have an active Convex subscription, you can set the spending limits for your team on the billing page:

Spending limits only apply to the resources used by your team’s projects beyond the amounts included in your plan. The seat fees (the amount paid for each developer in your team) are not counted towards the limits. For instance, if you send the spending limit to $0/month, you will be billed for the seat fees only and the projects will be disabled if you exceed the built-in resources included in your plan.

On the usage page you can see all the resources consumed by your team, and how you're tracking against your plan's limits.

Learn more about Convex pricing.

All metrics are available in daily breakdowns:

The Audit Log is only available on Convex Professional.

The audit log page shows all the actions taken by members within the team. This includes creating and managing projects and deployments, inviting and removing team members, and more.

You may also view a history of deployment-related events on the deployment history page.

---

## Full Text Search

**URL:** https://docs.convex.dev/text-search

**Contents:**
- Full Text Search
- Defining search indexes​
- Running search queries​
  - Search expressions​
  - Equality expressions​
  - Other filtering​
  - Retrieving results and paginating​
  - Ordering​
- Search Behavior​
  - Typeahead Search​

Full text search allows you to find Convex documents that approximately match a search query.

Unlike normal document queries, search queries look within a string field to find the keywords. Search queries are useful for building features like searching for messages that contain certain words.

Search queries are automatically reactive, consistent, transactional, and work seamlessly with pagination. They even include new documents created with a mutation!

To use full text search you need to:

Search indexes are built and queried using Convex's multi-segment search algorithm on top of Tantivy, a powerful, open-source, full-text search library written in Rust.

Like database indexes, search indexes are a data structure that is built in advance to enable efficient querying. Search indexes are defined as part of your Convex schema.

Every search index definition consists of:

To add a search index onto a table, use the searchIndex method on your table's schema. For example, if you want an index which can search for messages matching a keyword in a channel, your schema could look like:

You can specify search and filter fields on nested documents by using a dot-separated path like properties.name.

A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

This is just a normal database read that begins by querying the search index!

The .withSearchIndex method defines which search index to query and how Convex will use that search index to select documents. The first argument is the name of the index and the second is a search filter expression. A search filter expression is a description of which documents Convex should consider when running the query.

A search filter expression is always a chained list of:

Search expressions are issued against a search index, filtering and ranking documents by their relevance to the search expression's query. Internally, Convex will break up the query into separate words (called terms) and approximately rank documents matching these terms.

In the example above, the expression search("body", "hello hi") would internally be split into "hi" and "hello" and matched against words in your document (ignoring case and punctuation).

The behavior of search incorporates prefix matching rules.

Unlike search expressions, equality expressions will filter to only documents that have an exact match in the given field. In the example above, eq("channel", "#general") will only match documents that have exactly "#general" in their channel field.

Equality expressions support fields of any type (not just text).

To filter to documents that are missing a field, use q.eq("fieldName", undefined).

Because search queries are normal database queries, you can also filter results using the .filter method!

Here's a query for "messages containing 'hi' sent in the last 10 minutes":

For performance, always put as many of your filters as possible into .withSearchIndex.

Every search query is executed by:

Having a very specific search filter expression will make your query faster and less likely to hit Convex's limits because Convex will use the search index to efficiently cut down on the number of results to consider.

Just like ordinary database queries, you can retrieve the results using .collect(), .take(n), .first(), and .unique().

Additionally, search results can be paginated using .paginate(paginationOpts).

Note that collect() will throw an exception if it attempts to collect more than the limit of 1024 documents. It is often better to pick a smaller limit and use take(n) or paginate the results.

Search queries always return results in relevance order based on how well the document matches the search query. Different ordering of results are not supported.

Convex full-text search is designed to power as-you-type search experiences. In your search queries, the final search term has prefix search enabled, matching any term that is a prefix of the original term. For example, the expression search("body", "r") would match the documents:

Fuzzy search matches are deprecated. After January 15, 2025, search results will not include "snake" for a typo like "stake".

Relevance order is subject to change. The relevance of search results and the exact typo-tolerance rules Convex applies is subject to change to improve the quality of search results.

Search queries return results in relevance order. Internally, Convex ranks the relevance of a document based on a combination of its BM25 score and several other criteria such as the proximity of matches, the number of exact matches, and more. The BM25 score takes into account:

If multiple documents have the same score, the newest documents are returned first.

Search indexes work best with English or other Latin-script languages. Text is tokenized using Tantivy's SimpleTokenizer, which splits on whitespace and punctuation. We also limit terms to 32 characters in length and lowercase them.

Search indexes must have:

Search indexes count against the limit of 32 indexes per table.

Search queries can have:

Additionally, search queries can scan up to 1024 results from the search index.

The source of truth for these limits is our source code.

For information on other limits, see here.

**Examples:**

Example 1 (ts):
```ts
import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  messages: defineTable({    body: v.string(),    channel: v.string(),  }).searchIndex("search_body", {    searchField: "body",    filterFields: ["channel"],    staged: false,  }),});
```

Example 2 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) =>    q.search("body", "hello hi").eq("channel", "#general"),  )  .take(10);
```

Example 3 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) => q.search("body", "hi"))  .filter((q) => q.gt(q.field("_creationTime", Date.now() - 10 * 60000)))  .take(10);
```

---

## Convex Docs

**URL:** https://docs.convex.dev/home

**Contents:**
- Convex Docs
- Tutorial: Build a chat app
- Understanding Convex
- Get Started​
- Prompt to start an app with Convex Chef
- React
- Next.js
- Remix
- TanStack Start
- React Native

Convex is the open source, reactive database where queries are TypeScript code running right in the database. Just like React components react to state changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client libraries. It makes it easy to build and scale dynamic live-updating apps.

Follow a step-by-step tutorial to build your first Convex app - a real-time chat application.

Learn about the core concepts and architecture that make Convex unique and powerful.

Your favorite frameworks:

Your favorite languages:

Read the team's Perspectives on Stack:

See more walkthroughs and patterns on Stack

---

## Bundling

**URL:** https://docs.convex.dev/functions/bundling

**Contents:**
- Bundling
- Bundling for Convex​
- Bundling limitations​
  - Code size limits​
  - Dynamic dependencies​
- External packages​
  - Package installation on the server​
  - Specifying external packages​
  - Troubleshooting external packages​
    - Incorrect package versions​

Bundling is the process of gathering, optimizing and transpiling the JS/TS source code of functions and their dependencies. During development and when deploying, the code is transformed to a format that Convex runtimes can directly and efficiently execute.

Convex currently bundles all dependencies automatically, but for the Node.js runtime you can disable bundling certain packages via the external packages config.

When you push code either via npx convex dev or npx convex deploy, the Convex CLI uses esbuild to traverse your convex/ folder and bundle your functions and all of their used dependencies into a source code bundle. This bundle is then sent to the server.

Thanks to bundling you can write your code using both modern ECMAScript Modules (ESM) or the older CommonJS (CJS) syntax.

The nature of bundling comes with a few limitations.

The total size of your bundled function code in your convex/ folder is limited to 32MiB (~33.55MB). Other platform limits can be found here.

While this limit in itself is quite high for just source code, certain dependencies can quickly make your bundle size cross over this limit, particularly if they are not effectively tree-shakeable (such as aws-sdk or snowflake-sdk)

You can follow these steps to debug bundle size:

Note that this will not push code, and just generated a bundle for debugging purposes.

Use source-map-explorer to visualize your bundle.

Code bundled for the Convex runtime will be in the isolate directory while code bundled for node actions will be in the node directory.

Large node dependencies can be eliminated from the bundle by marking them as external packages.

Some libraries rely on dynamic imports (via import/require calls) to avoid always including their dependencies. These imports are not supported by the default Convex runtime and will throw an error at runtime.

Additionally, some libraries rely on local files, which cannot be bundled by esbuild. If bundling is used, irrespective of the choice of runtime, these imports will always fail in Convex.

Consider the following examples of packages relying on dynamic dependencies:

As a workaround for the bundling limitations above, Convex provides an escape hatch: external packages. This feature is currently exclusive to Convex's Node.js runtime.

External packages use esbuild's facility for marking a dependency as external. This tells esbuild to not bundle the external dependency at all and to leave the import as a dynamic runtime import using require() or import(). Thus, your Convex modules will rely on the underlying system having that dependency made available at execution-time.

Packages marked as external are installed from npm the first time you push code that uses them. The version installed matches the version installed in the node_modules folder on your local machine.

While this comes with a latency penalty the first time you push external packages, your packages are cached and this install step only ever needs to rerun if your external packages change. Once cached, pushes can actually be faster due to smaller source code bundles being sent to the server during pushes!

Create a convex.json file in the same directory as your package.json if it does not exist already. Set the node.externalPackages field to ["*"] to mark all dependencies used within your Node actions as external:

Alternatively, you can explicitly specify which packages to mark as external:

The package identifiers should match the string used in import/require in your Node.js action.

The Convex CLI searches for external packages within your local node_modules directory. Thus, changing version of a package in the package.json will not affect the version used on the server until you've updated the package version installed in your local node_modules folder (e.g. running npm install).

Marking a dependency as external may result in errors like this:

The requested module "some-module" is a CommonJs module, which may not support all module.exports as named exports. CommonJs modules can always be imported via the default export

This requires rewriting any imports for this module as follows:

The total size of your source code bundle and external packages cannot exceed the following:

Packages that are known not to work at this time:

If there is a package that you would like working in your Convex functions, let us know.

**Examples:**

Example 1 (sh):
```sh
npm install convex@latest
```

Example 2 (sh):
```sh
npx convex dev --once --debug-bundle-path /tmp/myBundle
```

Example 3 (sh):
```sh
npx source-map-explorer /tmp/myBundle/**/*.js
```

Example 4 (json):
```json
{  "node": {    "externalPackages": ["*"]  }}
```

---

## Debugging

**URL:** https://docs.convex.dev/functions/debugging

**Contents:**
- Debugging
- Debugging during development​
  - Using a debugger​
- Debugging in production​
- Finding relevant logs by Request ID​

Debugging is the process of figuring out why your code isn't behaving as you expect.

During development the built-in console API allows you to understand what's going on inside your functions:

The following methods are available in the default Convex runtime:

The Convex backend also automatically logs all successful function executions and all errors thrown by your functions.

You can view these logs:

You can exercise your functions from tests, in which case you can add debugger; statements and step through your code. See Testing.

When debugging an issue in production your options are:

Convex backend currently only preserves a limited number of logs, and logs can be erased at any time when the Convex team performs internal maintenance and upgrades. You should therefore set up log streaming and error reporting integrations to enable your team easy access to historical logs and additional information logged by your client.

To find the appropriate logs for an error you or your users experience, Convex includes a Request ID in all exception messages in both dev and prod in this format: [Request ID: <request_id>].

You can copy and paste a Request ID into your Convex dashboard to view the logs for functions started by that request. See the Dashboard logs page for details.

**Examples:**

Example 1 (ts):
```ts
import { mutation } from "./_generated/server";import { v } from "convex/values";export const mutateSomething = mutation({  args: { a: v.number(), b: v.number() },  handler: (_, args) => {    console.log("Received args", args);    // ...  },});
```

---

## Convex & WorkOS AuthKit

**URL:** https://docs.convex.dev/auth/authkit/

**Contents:**
- Convex & WorkOS AuthKit
- Get started​
  - Configuring an existing WorkOS account​
- Client configuration​
  - React​
  - Next.js​
- Next steps​
  - Accessing user information in functions​
  - Accessing user information client-side​
- Configuring dev and prod instances​

WorkOS AuthKit is an authentication solution that enables sign-in using passwords, social login providers, email one-time codes, two-factor authentication, and user management capabilities.

The quickest way to get started is to create an associated WorkOS account through the Convex CLI.

Follow the prompts to create a WorkOS team that will be associated with your Convex team. After this Convex deployments for projects in this team will be able to automatically provision and configure their own WorkOS environments.

That's it! After this you and other members of your Convex team can create and configure development WorkOS environments without visiting workos.com.

To use AuthKit with an existing WorkOS account you'll need to configure the account and copy credentials into the Convex deployment and your local .env.local file.

Sign up for a free WorkOS account at workos.com/sign-up.

In the WorkOS Dashboard, navigate to Authentication and then to AuthKit. From here, click the Set up AuthKit button to enable AuthKit in your account.

Press the Begin setup button with Use AuthKit's customizable hosted UI selected. These options can be filled out however you like until you get to step 4, Add default redirect endpoint URI.

The Redirect URI is the endpoint that WorkOS will return an authorization code to after signing in. This should match your application's domain and port, with /callback as the route. For example, if your application is running at localhost:5173 then the value here should be http://localhost:5173/callback.

Complete the AuthKit setup.

From the get started page under Quick start, find your WORKOS_CLIENT_ID and copy it.

Convex offers a provider that is specifically for integrating with WorkOS AuthKit called <ConvexProviderWithAuthKit>. It works using WorkOS's authkit-react SDK.

Once you've completed the WorkOS setup above, choose your framework below to continue with the integration.

See the following sections for the WorkOS SDK that you're using:

Example: React with Convex and AuthKit

This guide assumes you have AuthKit set up and have a working React app with Convex. If not follow the Convex React Quickstart first. Then:

In your WorkOS Dashboard, click Manage under "Cross-Origin Resource Sharing (CORS)" and add your local development domain (e.g., http://localhost:5173 for Vite) to the list. You'll also need to add your production domain when you deploy. This enables your application to authenticate users through WorkOS AuthKit.

In your .env.local file, add your WORKOS_CLIENT_ID and WORKOS_REDIRECT_URI environment variables. If you're using Vite, you'll need to prefix it with VITE_.

Note: These values can be found in your WorkOS Dashboard.

In your app's convex folder, create a new file auth.config.ts with the following code. This is the server-side configuration for validating access tokens.

Run npx convex dev to automatically sync your configuration to your backend.

You'll see an error and a link to click to fill in the WORKOS_CLIENT_ID environment variable in your Convex deployment. Follow the link, paste in the WorkOS client ID, save, and you should see the npx convex dev command show "Convex functions ready."

In a new terminal window, install the AuthKit React SDK:

AuthKit and Convex both have provider components that provide authentication and client context to your app.

You should already have <ConvexProvider> wrapping your app. Replace it with <ConvexProviderWithAuthKit>, and pass WorkOS's useAuth() hook to it.

Then, wrap it with <AuthKitProvider>. <AuthKitProvider> requires clientId and redirectUri props, which you can set to VITE_WORKOS_CLIENT_ID and VITE_WORKOS_REDIRECT_URI, respectively.

You can control which UI is shown when the user is signed in or signed out using Convex's <Authenticated>, <Unauthenticated> and <AuthLoading> helper components.

It's important to use the useConvexAuth() hook instead of AuthKit's useAuth() hook when you need to check whether the user is logged in or not. The useConvexAuth() hook makes sure that the browser has fetched the auth token needed to make authenticated requests to your Convex backend, and that the Convex backend has validated it.

In the following example, the <Content /> component is a child of <Authenticated>, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.

If the client is authenticated, you can access the information stored in the JWT via ctx.auth.getUserIdentity.

If the client isn't authenticated, ctx.auth.getUserIdentity will return null.

Make sure that the component calling this query is a child of <Authenticated> from convex/react. Otherwise, it will throw on page load.

Note: The React template repository includes additional features and functions for a complete working application. This tutorial covers the core integration steps, but the template provides a more comprehensive implementation.

Example: Next.js with Convex and AuthKit

This guide assumes you have AuthKit set up and have a working Next.js app with Convex. If not follow the Convex Next.js Quickstart first. Then:

In your .env.local file, add the following environment variables:

In your app's convex folder, create a new file auth.config.ts with the following code. This is the server-side configuration for validating access tokens.

Run npx convex dev to automatically sync your configuration to your backend.

You'll see an error and a link to click to fill in the WORKOS_CLIENT_ID environment variable in your Convex deployment. Follow the link, paste in the WorkOS client ID, save, and you should see the npx convex dev command show "Convex functions ready."

In a new terminal window, install the AuthKit Next.js SDK:

AuthKit's authkitMiddleware() helper grants you access to user authentication state throughout your app.

Create a middleware.ts file.

In your middleware.ts file, export the authkitMiddleware() helper:

Create the required authentication routes for WorkOS AuthKit to handle sign-in, sign-up, and callback flows.

These routes enable the authentication flow by providing endpoints for users to sign in, sign up, and return after authentication.

Create the callback route to handle OAuth callbacks:

To redirect users to WorkOS sign-up:

Your Next.js app needs to connect AuthKit authentication with Convex for real-time data. We'll create a single provider component that handles both.

Create the Provider Component

This single component handles:

Create components/ConvexClientProvider.tsx:

Update app/layout.tsx to use the provider:

You can control which UI is shown when the user is signed in or signed out using Convex's <Authenticated>, <Unauthenticated> and <AuthLoading> helper components. These should be used instead of WorkOS AuthKit's useAuth() loading states and manual authentication checks.

It's important to use the useConvexAuth() hook instead of WorkOS AuthKit's useAuth() hook when you need to check whether the user is logged in or not. The useConvexAuth() hook makes sure that the browser has fetched the auth token needed to make authenticated requests to your Convex backend, and that the Convex backend has validated it.

In the following example, the <Content /> component is a child of <Authenticated>, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.

If the client is authenticated, you can access the information stored in the JWT via ctx.auth.getUserIdentity.

If the client isn't authenticated, ctx.auth.getUserIdentity will return null.

Make sure that the component calling this query is a child of <Authenticated> from convex/react. Otherwise, it will throw on page load.

Note: The Next.js template repository includes additional features and functions for a complete working application. This tutorial covers the core integration steps, but the template provides a more comprehensive implementation.

See Auth in Functions to learn about how to access information about the authenticated user in your queries, mutations and actions.

See Storing Users in the Convex Database to learn about how to store user information in the Convex database.

To access the authenticated user's information, use AuthKit's User object, which can be accessed using AuthKit's useAuth() hook. For more information on the User object, see the WorkOS docs.

To configure a different AuthKit instance between your Convex development and production deployments, you can use environment variables configured on the Convex dashboard.

In the WorkOS Dashboard, navigate to the API keys page. Copy your WorkOS Client ID. This Client ID is necessary for Convex to validate access tokens from WorkOS AuthKit. In development, its format will be client_01XXXXXXXXXXXXXXXXXXXXXXXX. In production, it will follow the same format but represent your production WorkOS application.

Paste your WorkOS Client ID into your .env file, set it as the WORKOS_CLIENT_ID environment variable. Note that this environment variable is used server-side and does not need a NEXT_PUBLIC_ prefix.

Then, update your convex/auth.config.ts file to use the environment variable:

Development configuration

In the left sidenav of the Convex dashboard, switch to your development deployment and set the WORKOS_CLIENT_ID environment variable to your development WorkOS Client ID.

Then, to switch your deployment to the new configuration, run npx convex dev.

Production configuration

In the left sidenav of the Convex dashboard, switch to your production deployment and set the WORKOS_CLIENT_ID environment variable to your production WorkOS Client ID.

Then, to switch your deployment to the new configuration, run npx convex deploy.

WorkOS AuthKit's API keys differ depending on whether they are for development or production. Don't forget to update the environment variables in your .env file as well as your hosting platform, such as Vercel or Netlify.

Development configuration

WorkOS API Key for development follows the format sk_test_.... WorkOS Client ID for development follows the format client_01....

Production configuration

WorkOS API Key for production follows the format sk_live_.... WorkOS Client ID for production follows the format client_01....

WorkOS AuthKit requires additional configuration:

Cookie Password: A secure password used to encrypt session cookies. This must be at least 32 characters long. You can generate a random one with openssl rand -base64 24.

Redirect URI: The URL where users are redirected after authentication. This must be configured in both your environment variables and your WorkOS Dashboard application settings.

If a user goes through the WorkOS AuthKit login flow successfully, and after being redirected back to your page, useConvexAuth() returns isAuthenticated: false, it's possible that your backend isn't correctly configured.

The convex/auth.config.ts file contains a list of configured authentication providers. You must run npx convex dev or npx convex deploy after adding a new provider to sync the configuration to your backend.

Common issues with WorkOS AuthKit integration:

For more thorough debugging steps, see the WorkOS AuthKit documentation or Debugging Authentication.

The authentication flow looks like this under the hood:

ConvexProviderWithAuthKit takes care of refetching the token when needed to make sure the user stays authenticated with your backend.

**Examples:**

Example 1 (bash):
```bash
npm create convex@latest -- -t react-vite-authkitcd my-app  # or whatever you name the directorynpm run dev
```

Example 2 (env):
```env
# WorkOS AuthKit ConfigurationVITE_WORKOS_CLIENT_ID=your-workos-client-id-hereVITE_WORKOS_REDIRECT_URI=http://localhost:5173/callback
```

Example 3 (ts):
```ts
const clientId = process.env.WORKOS_CLIENT_ID;const authConfig = {  providers: [    {      type: 'customJwt',      issuer: `https://api.workos.com/`,      algorithm: 'RS256',  jwks: `https://api.workos.com/sso/jwks/${clientId}`,  applicationID: clientId,    },    {      type: 'customJwt',      issuer: `https://api.workos.com/user_management/${clientId}`,      algorithm: 'RS256',      jwks: `https://api.workos.com/sso/jwks/${clientId}`,      applicationID: clientId,    },  ],};export default authConfig;
```

Example 4 (sh):
```sh
npx convex dev
```

---

## AI & Search

**URL:** https://docs.convex.dev/search

**Contents:**
- AI & Search

Whether building RAG enabled chatbots or quick search in your applications, Convex provides easy apis to create powerful AI and search enabled products.

Vector Search enables searching for documents based on their semantic meaning. It uses vector embeddings to calculate similarity and retrieve documents that are similar to a given query. Vector search is a key part of common AI techniques like RAG.

Full Text Search enables keyword and phrase search within your documents. It supports prefix matching to enable typeahead search. Convex full text search is also reactive and always up to date like all Convex queries, making it easy to build reliable quick search boxes.

Convex Actions easily enable you to call AI apis, save data to your database, and drive your user interface. See examples of how you can use this to build sophisticated AI applications.

---

## Errors and Warnings

**URL:** https://docs.convex.dev/error/

**Contents:**
- Errors and Warnings
- Write conflict: Optimistic concurrency control​
  - Example A​
  - Example B​
  - Remediation​
  - Resources​

This page explains specific errors thrown by Convex.

See Error Handling to learn about handling errors in general.

This system error is thrown when a mutation repeatedly fails due to conflicting changes from parallel mutation executions.

A mutation updateCounter always updates the same document:

If this mutation is called many times per second, many of its executions will conflict with each other. Convex internally does several retries to mitigate this concern, but if the mutation is called more rapidly than Convex can execute it, some of the invocations will eventually throw this error:

Documents read from or written to the table "counters" changed while this mutation was being run and on every subsequent retry. Another call to this mutation changed the document with ID "123456789101112".

The error message will note the table name, which mutation caused the conflict (in this example its another call to the same mutation), and one document ID which was part of the conflicting change.

Mutation writeCount depends on the entire tasks table:

If the mutation writeCount is called at the same time as many calls to addTask are made, either of the mutations can fail with this error. This is because any change to the "tasks" table will conflict with the writeCount mutation:

Documents read from or written to the table "tasks" changed while this mutation was being run and on every subsequent retry. A call to "addTask" changed the document with ID "123456789101112".

**Examples:**

Example 1 (ts):
```ts
export const updateCounter = mutation({  args: {},  handler: async (ctx) => {    const doc = await ctx.db.get(process.env.COUNTER_ID);    await ctx.db.patch(doc._id, { value: doc.value + 1 });  },});
```

Example 2 (ts):
```ts
export const writeCount = mutation({  args: {    target: v.id("counts"),  },  handler: async (ctx, args) => {    const tasks = await ctx.db.query("tasks").collect();    await ctx.db.patch(args.target, { value: tasks });  },});export const addTask = mutation({  args: {    text: v.string(),  },  handler: async (ctx, args) => {    await ctx.db.insert("tasks", { text: args.text });  },});
```

---

## Argument and Return Value Validation

**URL:** https://docs.convex.dev/functions/validation

**Contents:**
- Argument and Return Value Validation
- Adding validators​
- Supported types​
  - Convex values​
  - Unions​
  - Literals​
  - Record objects​
  - Any​
  - Optional fields​
- Extracting TypeScript types​

Argument and return value validators ensure that queries, mutations, and actions are called with the correct types of arguments and return the expected types of return values.

This is important for security! Without argument validation, a malicious user can call your public functions with unexpected arguments and cause surprising results. TypeScript alone won't help because TypeScript types aren't present at runtime. We recommend adding argument validation for all public functions in production apps. For non-public functions that are not called by clients, we recommend internal functions and optionally validation.

Example: Argument Validation

To add argument validation to your functions, pass an object with args and handler properties to the query, mutation or action constructor. To add return value validation, use the returns property in this object:

If you define your function with an argument validator, there is no need to include TypeScript type annotations! The type of your function will be inferred automatically. Similarly, if you define a return value validator, the return type of your function will be inferred from the validator, and TypeScript will check that it matches the inferred return type of the handler function.

Unlike TypeScript, validation for an object will throw if the object contains properties that are not declared in the validator.

If the client supplies arguments not declared in args, or if the function returns a value that does not match the validator declared in returns. This is helpful to prevent bugs caused by mistyped names of arguments or returning more data than intended to a client.

Even args: {} is a helpful use of validators because TypeScript will show an error on the client if you try to pass any arguments to the function which doesn't expect them.

All functions, both public and internal, can accept and return the following data types. Each type has a corresponding validator that can be accessed on the v object imported from "convex/values".

The database can store the exact same set of data types.

Additionally you can also express type unions, literals, any types, and optional fields.

Convex supports the following types of values:

You can describe fields that could be one of multiple types using v.union:

Fields that are a constant can be expressed with v.literal. This is especially useful when combined with unions:

You can describe objects that map arbitrary keys to values with v.record:

You can use other types of string validators for the keys:

Fields that could take on any value can be represented with v.any():

This corresponds to the any type in TypeScript.

You can describe optional fields by wrapping their type with v.optional(...):

This corresponds to marking fields as optional with ? in TypeScript.

The Infer type allows you to turn validator calls into TypeScript types. This can be useful to remove duplication between your validators and TypeScript types:

**Examples:**

Example 1 (ts):
```ts
import { mutation, query } from "./_generated/server";import { v } from "convex/values";export const send = mutation({  args: {    body: v.string(),    author: v.string(),  },  returns: v.null(),  handler: async (ctx, args) => {    const { body, author } = args;    await ctx.db.insert("messages", { body, author });  },});
```

Example 2 (typescript):
```typescript
import { mutation } from "./_generated/server";import { v } from "convex/values";export default mutation({  args: {    stringOrNumber: v.union(v.string(), v.number()),  },  handler: async ({ db }, { stringOrNumber }) => {    //...  },});
```

Example 3 (typescript):
```typescript
import { mutation } from "./_generated/server";import { v } from "convex/values";export default mutation({  args: {    oneTwoOrThree: v.union(      v.literal("one"),      v.literal("two"),      v.literal("three"),    ),  },  handler: async ({ db }, { oneTwoOrThree }) => {    //...  },});
```

Example 4 (typescript):
```typescript
import { mutation } from "./_generated/server";import { v } from "convex/values";export default mutation({  args: {    simpleMapping: v.record(v.string(), v.boolean()),  },  handler: async ({ db }, { simpleMapping }) => {    //...  },});
```

---

## Scheduling

**URL:** https://docs.convex.dev/scheduling

**Contents:**
- Scheduling
- Durable function components​
  - Workpool
  - Workflow
  - Action Retrier
  - Crons

Convex lets you easily schedule a function to run once or repeatedly in the future. This allows you to build durable workflows like sending a welcome email a day after someone joins or regularly reconciling your accounts with Stripe. Convex provides two different features for scheduling:

Built-in scheduled functions and crons work well for simpler apps and workflows. If you're operating at high scale or need more specific guarantees, use the following higher-level components for durable functions.

Workpool give critical tasks priority by organizing async operations into separate, customizable queues.

Simplify programming long running code flows. Workflows execute durably with configurable retries and delays.

Add reliability to an unreliable external service. Retry idempotent calls a set number of times.

Use cronspec to run functions on a repeated schedule at runtime.

---

## Full Text Search

**URL:** https://docs.convex.dev/search/text-search

**Contents:**
- Full Text Search
- Defining search indexes​
- Running search queries​
  - Search expressions​
  - Equality expressions​
  - Other filtering​
  - Retrieving results and paginating​
  - Ordering​
- Search Behavior​
  - Typeahead Search​

Full text search allows you to find Convex documents that approximately match a search query.

Unlike normal document queries, search queries look within a string field to find the keywords. Search queries are useful for building features like searching for messages that contain certain words.

Search queries are automatically reactive, consistent, transactional, and work seamlessly with pagination. They even include new documents created with a mutation!

To use full text search you need to:

Search indexes are built and queried using Convex's multi-segment search algorithm on top of Tantivy, a powerful, open-source, full-text search library written in Rust.

Like database indexes, search indexes are a data structure that is built in advance to enable efficient querying. Search indexes are defined as part of your Convex schema.

Every search index definition consists of:

To add a search index onto a table, use the searchIndex method on your table's schema. For example, if you want an index which can search for messages matching a keyword in a channel, your schema could look like:

You can specify search and filter fields on nested documents by using a dot-separated path like properties.name.

A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

This is just a normal database read that begins by querying the search index!

The .withSearchIndex method defines which search index to query and how Convex will use that search index to select documents. The first argument is the name of the index and the second is a search filter expression. A search filter expression is a description of which documents Convex should consider when running the query.

A search filter expression is always a chained list of:

Search expressions are issued against a search index, filtering and ranking documents by their relevance to the search expression's query. Internally, Convex will break up the query into separate words (called terms) and approximately rank documents matching these terms.

In the example above, the expression search("body", "hello hi") would internally be split into "hi" and "hello" and matched against words in your document (ignoring case and punctuation).

The behavior of search incorporates prefix matching rules.

Unlike search expressions, equality expressions will filter to only documents that have an exact match in the given field. In the example above, eq("channel", "#general") will only match documents that have exactly "#general" in their channel field.

Equality expressions support fields of any type (not just text).

To filter to documents that are missing a field, use q.eq("fieldName", undefined).

Because search queries are normal database queries, you can also filter results using the .filter method!

Here's a query for "messages containing 'hi' sent in the last 10 minutes":

For performance, always put as many of your filters as possible into .withSearchIndex.

Every search query is executed by:

Having a very specific search filter expression will make your query faster and less likely to hit Convex's limits because Convex will use the search index to efficiently cut down on the number of results to consider.

Just like ordinary database queries, you can retrieve the results using .collect(), .take(n), .first(), and .unique().

Additionally, search results can be paginated using .paginate(paginationOpts).

Note that collect() will throw an exception if it attempts to collect more than the limit of 1024 documents. It is often better to pick a smaller limit and use take(n) or paginate the results.

Search queries always return results in relevance order based on how well the document matches the search query. Different ordering of results are not supported.

Convex full-text search is designed to power as-you-type search experiences. In your search queries, the final search term has prefix search enabled, matching any term that is a prefix of the original term. For example, the expression search("body", "r") would match the documents:

Fuzzy search matches are deprecated. After January 15, 2025, search results will not include "snake" for a typo like "stake".

Relevance order is subject to change. The relevance of search results and the exact typo-tolerance rules Convex applies is subject to change to improve the quality of search results.

Search queries return results in relevance order. Internally, Convex ranks the relevance of a document based on a combination of its BM25 score and several other criteria such as the proximity of matches, the number of exact matches, and more. The BM25 score takes into account:

If multiple documents have the same score, the newest documents are returned first.

Search indexes work best with English or other Latin-script languages. Text is tokenized using Tantivy's SimpleTokenizer, which splits on whitespace and punctuation. We also limit terms to 32 characters in length and lowercase them.

Search indexes must have:

Search indexes count against the limit of 32 indexes per table.

Search queries can have:

Additionally, search queries can scan up to 1024 results from the search index.

The source of truth for these limits is our source code.

For information on other limits, see here.

**Examples:**

Example 1 (ts):
```ts
import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  messages: defineTable({    body: v.string(),    channel: v.string(),  }).searchIndex("search_body", {    searchField: "body",    filterFields: ["channel"],    staged: false,  }),});
```

Example 2 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) =>    q.search("body", "hello hi").eq("channel", "#general"),  )  .take(10);
```

Example 3 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) => q.search("body", "hi"))  .filter((q) => q.gt(q.field("_creationTime", Date.now() - 10 * 60000)))  .take(10);
```

---

## Scheduled Functions

**URL:** https://docs.convex.dev/scheduling/scheduled-functions

**Contents:**
- Scheduled Functions
- Scheduling functions​
  - Scheduling from mutations​
  - Scheduling from actions​
  - Scheduling immediately​
- Retrieving scheduled function status​
- Canceling scheduled functions​
- Debugging​
- Error handling​
- Auth​

Convex allows you to schedule functions to run in the future. This allows you to build powerful durable workflows without the need to set up and maintain queues or other infrastructure.

Scheduled functions are stored in the database. This means you can schedule functions minutes, days, and even months in the future. Scheduling is resilient against unexpected downtime or system restarts.

You can schedule public functions and internal functions from mutations and actions via the scheduler provided in the respective function context.

The rest of the arguments are the path to the function and its arguments, similar to invoking a function from the client. For example, here is how to send a message that self-destructs in five seconds.

A single function can schedule up to 1000 functions with total argument size of 8MB.

Scheduling functions from mutations is atomic with the rest of the mutation. This means that if the mutation succeeds, the scheduled function is guaranteed to be scheduled. On the other hand, if the mutations fails, no function will be scheduled, even if the function fails after the scheduling call.

Unlike mutations, actions don't execute as a single database transaction and can have side effects. Thus, scheduling from actions does not depend on the outcome of the function. This means that an action might succeed to schedule some functions and later fail due to transient error or a timeout. The scheduled functions will still be executed.

Using runAfter() with delay set to 0 is used to immediately add a function to the event queue. This usage may be familiar to you if you're used to calling setTimeout(fn, 0).

As noted above, actions are not atomic and are meant to cause side effects. Scheduling immediately becomes useful when you specifically want to trigger an action from a mutation that is conditional on the mutation succeeding. This post goes over a direct example of this in action, where the application depends on an external service to fill in information to the database.

Every scheduled function is reflected as a document in the "_scheduled_functions" system table. runAfter() and runAt() return the id of scheduled function. You can read data from system tables using the db.system.get and db.system.query methods, which work the same as the standard db.get and db.query methods.

This is an example of the returned document:

The returned document has the following fields:

Scheduled function results are available for 7 days after they have completed.

You can cancel a previously scheduled function with cancel via the scheduler provided in the respective function context.

What cancel does depends on the state of the scheduled function:

You can view logs from previously executed scheduled functions in the Convex dashboard Logs view. You can view and cancel yet to be executed functions in the Functions view.

Once scheduled, mutations are guaranteed to be executed exactly once. Convex will automatically retry any internal Convex errors, and only fail on developer errors. See Error Handling for more details on different error types.

Since actions may have side effects, they are not automatically retried by Convex. Thus, actions will be executed at most once, and permanently fail if there are transient errors while executing them. Developers can retry those manually by scheduling a mutation that checks if the desired outcome has been achieved and if not schedule the action again.

The auth is not propagated from the scheduling to the scheduled function. If you want to authenticate or check authorization, you'll have to pass the requisite user information in as a parameter.

**Examples:**

Example 1 (ts):
```ts
import { mutation, internalMutation } from "./_generated/server";import { internal } from "./_generated/api";import { v } from "convex/values";export const sendExpiringMessage = mutation({  args: { body: v.string(), author: v.string() },  handler: async (ctx, args) => {    const { body, author } = args;    const id = await ctx.db.insert("messages", { body, author });    await ctx.scheduler.runAfter(5000, internal.messages.destruct, {      messageId: id,    });  },});export const destruct = internalMutation({  args: {    messageId: v.id("messages"),  },  handler: async (ctx, args) => {    await ctx.db.delete(args.messageId);  },});
```

Example 2 (ts):
```ts
export const listScheduledMessages = query({  args: {},  handler: async (ctx, args) => {    return await ctx.db.system.query("_scheduled_functions").collect();  },});export const getScheduledMessage = query({  args: {    id: v.id("_scheduled_functions"),  },  handler: async (ctx, args) => {    return await ctx.db.system.get(args.id);  },});
```

Example 3 (json):
```json
{  "_creationTime": 1699931054642.111,  "_id": "3ep33196167235462543626ss0scq09aj4gqn9kdxrdr",  "args": [{}],  "completedTime": 1699931054690.366,  "name": "messages.js:destruct",  "scheduledTime": 1699931054657,  "state": { "kind": "success" }}
```

Example 4 (ts):
```ts
export const cancelMessage = mutation({  args: {    id: v.id("_scheduled_functions"),  },  handler: async (ctx, args) => {    await ctx.scheduler.cancel(args.id);  },});
```

---

## Testing Local Backend

**URL:** https://docs.convex.dev/testing/convex-backend

**Contents:**
- Testing Local Backend
- Getting Started​
- Limitations​
- CI​

Alternatively to convex-test you can test your functions using the open-source version of the Convex backend.

Follow this guide for the instructions.

Compared to convex-test, which uses a JS mock of the backend, running your tests against the real backend has these advantages:

Note that testing against the local backend also has some drawbacks:

To test your functions in JS with a mocked Convex backend, check out convex-test.

See Continuous Integration to run your tests on a shared remote machine.

---

## Deploy keys

**URL:** https://docs.convex.dev/cli/deploy-key-types

**Contents:**
- Deploy keys
  - Developing locally does not require a deploy key​
  - How to set a deploy key​
- Common uses of deploy keys
  - Deploying from build pipelines​
  - Deploying to preview deployments​
  - Admin keys​
- Rarer types of deploy keys​
  - Project tokens​
  - Development deploy keys​

When you can't log in or use the CLI interactively to specify a project or deployment, for example in a production build environment, the environment variable CONVEX_DEPLOY_KEY can be set to a deploy key to make convex CLI commands run non-interactively.

Deploy keys identify a deployment, project, or team; confer permission to take certain actions with those resources; and can change the behavior of the convex CLI.

Running npx convex dev on a new machine offers the choice to log in or run Convex locally without an account.

Logging in stores a user token at ~/.convex/config.json which is used automatically for all CLI use going forward on that machine. This token grants permission to push code to and read/write data from any deployment this user has access to.

Using Convex locally without logging in (anonymous development) creates a deployment locally and records this preference for this project in the .env.local file in the project directory. The admin key for this anonymous backend is stored in ~/.convex/anonymous-convex-backend-state/ along with its serialized data.

In either of these cases, there's no reason to set CONVEX_DEPLOY_KEY.

Generally deploys keys are set in a dashboard of the service that needs the key but in most shells you can set it right before the command, like

or export it before you run the command

or add it to your .env.local file where it will be found by npx convex when run in that directory.

A production deploy key specifies the production deployment of a project and grants permissions to deploy code to it.

prod:qualified-jaguar-123|eyJ2...0=

You can deploying code from a build pipeline where you can't log in (e.g. Vercel, Netlify, Cloudflare build pipelines)

Read more about deploying to production.

A preview deploy key looks like this:

preview:team-slug:project-slug|eyJ2...0=

Use a preview deploy key to change the behavior of a normal npx convex deploy command to deploy to a preview branch.

Read more about preview deployments.

An admin key provides complete control over a deployment.

An admin key might look like

bold-hyena-681|01c2...c09c

Unlike other types of deploy key, an admin key does not require a network connection to https://convex.dev to be used since it's a irrevocable secret baked into the deployment when created.

These keys are used to control anonymous Convex deployments locally without logging in, but rarely need to be set explicitly.

Setting CONVEX_DEPLOY_KEY to one will cause the Convex CLI to run against that deployment instead of offering a choice.

A project token grants total control over a project to a convex CLI and carries with it the permission to create and use development and production deployments in that project.

project:team-slug:project-slug|eyJ2...0=

Project tokens are obtained when a user grants an permission to use a project to an organization via an Convex OAuth application. Actions made with the token are on behalf of the user so if a user loses access to a project the token no longer grant access to it.

A dev deploy key might be used to provide an agent full access to a single deployment for development.

dev:joyful-jaguar-123|eyJ2...0=

This can help limit the blast radius when developing with an agent.

To give an agent exclusive access to its own dev deployment, see Agent Mode.

**Examples:**

Example 1 (text):
```text
CONVEX_DEPLOY_KEY='key goes here' npx convex dev
```

Example 2 (text):
```text
export CONVEX_DEPLOY_KEY='key goes here'npx convex dev
```

---

## Debugging Authentication

**URL:** https://docs.convex.dev/auth/debug

**Contents:**
- Debugging Authentication
- Frequently encountered issues​
  - ctx.auth.getUserIdentity() returns null in a query​
- Step 1: Check whether authentication works on the backend​
- Step 2: Check whether authentication works on the frontend​
- Step 3: Check that backend configuration matches frontend configuration​

You have followed one of our authentication guides but something is not working. You have double checked that you followed all the steps, and that you used the correct secrets, but you are still stuck.

This often happens when subscribing to queries via useQuery in React, without waiting for the client to be authenticated. Even if the user has been logged-in previously, it takes some time for the client to authenticate with the Convex backend. Therefore on page load, ctx.auth.getUserIdentity() called within a query returns null.

To handle this, you can either:

If you are using fetchQuery for Next.js Server Rendering, make sure you are explicitly passing in a JWT token as documented here.

If this hasn't helped, follow the steps below to resolve your issue.

Then call this function from whichever client you're using to talk to Convex.

Open the logs page on your dashboard.

What do you see on the logs page?

Answer: I don't see anything:

When you resolved the cause you should see the log appear.

Answer: I see a log with 'server identity' null:

Answer: I see a log with 'server identity' { tokenIdentifier: '... }

Great, you are all set!

No matter which client you use, it must pass a JWT token to your backend for authentication to work.

The most bullet-proof way of ensuring your client is passing the token to the backend, is to inspect the traffic between them.

If you're using a client from the web browser, open the Network tab in your browser's developer tools.

For Websocket-based clients (ConvexReactClient and ConvexClient), filter for the sync name and select WS as the type of traffic. Check the sync items. After the client is initialized (commonly after loading the page), it will send a message (check the Messages tab) with type: "Authenticate", and value will be the authentication token.

For HTTP based clients (ConvexHTTPClient and the HTTP API), select Fetch/XHR as the type of traffic. You should see an individual network request for each function call, with an Authorization header with value Bearer followed by the authentication token.

Do you see the authentication token in the traffic?

Potential cause: The Convex client is not configured to get/fetch a JWT token. You're not using ConvexProviderWithClerk/ConvexProviderWithAuth0/ConvexProviderWithAuth with the ConvexReactClient or you forgot to call setAuth on ConvexHTTPClient or ConvexClient.

Potential cause: You are not signed in, so the token is null or undefined and the ConvexReactClient skipped authentication altogether. Verify that you are signed in via console.loging the token from whichever auth provider you are using:

Custom: However you implemented useAuthFromProviderX

If you don't see a long string that looks like a token, check the browser logs for errors from your auth provider. If there are none, check the Network tab to see whether requests to your provider are failing. Perhaps the auth provider is misconfigured. Double check the auth provider configuration (in the corresponding React provider or however your auth provider is configured for the client). Try clearing your cookies in the browser (in dev tools Application > Cookies > Clear all cookies button).

Answer: Yes, I see a long string that looks like a JWT:

Great, copy the whole token (there can be .s in it, so make sure you're not copying just a portion of it).

Open https://jwt.io/, scroll down and paste the token in the Encoded textarea on the left of the page. On the right you should see:

If you see a valid JWT token, repeat step 1. If you still don't see correct identity, proceed to step 3.

You have a valid JWT token on the frontend, and you know that it is being passed to the backend, but the backend is not validating it.

Open the Settings > Authentication on your dashboard. What do you see?

Answer: I see This deployment has no configured authentication providers:

**Answer: I see one or more Domain and Application ID pairs.

Great, let's check they match the JWT token.

Look at the iss field in the JWT token payload at https://jwt.io/. Does it match a Domain on the Authentication page?

Answer: No, I don't see the iss URL on the Convex dashboard:

Potential cause: You copied the wrong value into your

's domain, or into the environment variable that is used there. Go back to the authentication guide and make sure you have the right URL from your auth provider.

Potential cause: Your client is misconfigured:

Clerk: You have the wrong publishableKey configured. The key must belong to the Clerk instance that you used to configure your

Auth0: You have the wrong domain configured (on the client!). The domain must belong to the Auth0 instance that you used to configure your auth.config.ts.

Custom: Make sure that your client is correctly configured to match your auth.config.ts.

Answer: Yes, I do see the iss URL:

Great, let's move one.

Look at the aud field in the JWT token payload at https://jwt.io/. Does it match the Application ID under the correct Domain on the Authentication page?

Answer: No, I don't see the aud value in the Application ID field:

Answer: Yes, I do see the aud value in the Application ID field:

Great, repeat step 1 and you should be all set!

**Examples:**

Example 1 (ts):
```ts
console.log("server identity", await ctx.auth.getUserIdentity());
```

Example 2 (tsx):
```tsx
// import { useAuth } from "@clerk/nextjs"; // for Next.jsimport { useAuth } from "@clerk/clerk-react";const { getToken } = useAuth();console.log(getToken({ template: "convex" }));
```

Example 3 (tsx):
```tsx
import { useAuth0 } from "@auth0/auth0-react";const { getAccessTokenSilently } = useAuth0();const response = await getAccessTokenSilently({  detailedResponse: true,});const token = response.id_token;console.log(token);
```

---

## Settings

**URL:** https://docs.convex.dev/dashboard/deployments/deployment-settings

**Contents:**
- Settings
- URL and Deploy Key​
- Environment Variables​
- Authentication​
- Backup & Restore​
- Integrations​
- Pause Deployment​

The deployment settings page gives you access to information and configuration options related to a specific deployment (production, your personal development deployment, or a preview deployment).

The URL and deploy key page shows:

The environment variables page lets you add, change, remove and copy the deployment's environment variables.

The authentication page shows the values configured in your auth.config.js for user authentication implementation.

The backup & restore page lets you backup the data stored in your deployment's database and file storage. On this page, you can schedule periodic backups.

The integrations page allows you to configure log streaming, exception reporting, and streaming export integrations.

On the pause deployment page you can pause your deployment with the pause button.

---

## Components

**URL:** https://docs.convex.dev/components

**Contents:**
- Components
- Full Components Directory
- Durable Functions​
- Workflow
- Workpool
- Crons
- Action Retrier
- Database​
- Sharded Counter
- Migrations

Convex Components package up code and data in a sandbox that allows you to confidently and quickly add new features to your backend.

Convex Components are like mini self-contained Convex backends, and installing them is always safe. They can't read your app's tables or call your app's functions unless you pass them in explicitly.

You can read about the full vision in Convex: The Software-Defined Database

The Convex team has built a few components that add new features to your backend. You'll eventually be able to author your own components to use within your project and to share with the community, but we haven't stabilized and documented the authoring APIs yet.

Each component is installed as its own independent library from NPM. Check out the component's README for installation and usage instructions. You can see the full directory on the Convex website.

Async code flow as durable functions.

Async durable function queue.

Dynamic runtime cron management

Retry failed external calls automatically

High-throughput counter operations

Define and run migrations

Efficient sums and counts

Store and search locations

Store and serve files

Real-time collaborative text editing

Send mobile push notifications

Send and receive SMS messages

Sync feature flags with backend

Add subscriptions and billing

Define agents with tools and memory

Stream and store text data

Control resource usage rates

Cache expensive external calls

The underlying authoring APIs for components are still in flux. The Convex team authored components listed below will be kept up to date as the APIs change.

Components can be thought of as a combination of concepts from frontend components, third party APIs, and both monolith and service-oriented architectures.

Similar to frontend components, Convex Components encapsulate state and behavior and allow exposing a clean interface. However, instead of just storing state in memory, these can have internal state machines that can persist between user sessions, span users, and change in response to external inputs, such as webhooks. Components can store data in a few ways:

Typically, libraries require configuring a third party service to add stateful off-the-shelf functionality, which lack the transactional guarantees that come from storing state in the same database.

Similar to regular npm libraries, Convex Components include functions, type safety, and are called from your code. However, they also provide extra guarantees.

Being able to reason about your code is essential to scaling a codebase. Components allow you to reason about API boundaries and abstractions.

---

## Queries

**URL:** https://docs.convex.dev/understanding/convex-fundamentals/functions

**Contents:**
- Queries
- Query names​
- The query constructor​
  - Query arguments​
  - Query responses​
  - Query context​
- Splitting up query code via helpers​
- Using NPM packages​
- Calling queries from clients​
- Caching & reactivity & consistency​

Queries are the bread and butter of your backend API. They fetch data from the database, check authentication or perform other business logic, and return data back to the client application.

This is an example query, taking in named arguments, reading data from the database and returning a result:

Read on to understand how to build queries yourself.

Queries are defined in

The path and name of the file, as well as the way the function is exported from the file, determine the name the client will use to call it:

To structure your API you can nest directories inside the convex/ directory:

Default exports receive the name default.

The same rules apply to mutations and actions, while HTTP actions use a different routing approach.

Client libraries in languages other than JavaScript and TypeScript use strings instead of API objects:

To actually declare a query in Convex you use the query constructor function. Pass it an object with a handler function, which returns the query result:

Queries accept named arguments. The argument values are accessible as fields of the second parameter of the handler function:

Arguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your query.

To both declare the types of arguments and to validate them, add an args object using v validators:

See argument validation for the full list of supported types and validators.

The first parameter of the handler function contains the query context.

Queries can return values of any supported Convex type which will be automatically serialized and deserialized.

Queries can also return undefined, which is not a valid Convex value. When a query returns undefined it is translated to null on the client.

The query constructor enables fetching data, and other Convex features by passing a QueryCtx object to the handler function as the first parameter:

Which part of the query context is used depends on what your query needs to do:

To fetch from the database use the db field. Note that we make the handler function an async function so we can await the promise returned by db.get():

Read more about Reading Data.

To return URLs to stored files use the storage field. Read more about File Storage.

To check user authentication use the auth field. Read more about Authentication.

When you want to split up the code in your query or reuse logic across multiple Convex functions you can define and call helper

You can export helpers to use them across multiple files. They will not be callable from outside of your Convex functions.

See Type annotating server side helpers for more guidance on TypeScript types.

Queries can import NPM packages installed in node_modules. Not all NPM packages are supported, see Runtimes for more details.

To call a query from React use the useQuery hook along with the generated api object.

See the React client documentation for all the ways queries can be called.

Queries have three awesome attributes:

To have these attributes the handler function must be deterministic, which means that given the same arguments (including the query context) it will return the same response.

For this reason queries cannot fetch from third party APIs. To call third party APIs, use actions.

You might wonder whether you can use non-deterministic language functionality like Math.random() or Date.now(). The short answer is that Convex takes care of implementing these in a way that you don't have to think about the deterministic constraint.

See Runtimes for more details on the Convex runtime.

Queries have a limit to the amount of data they can read at once to guarantee good performance. Check out these limits in Read/write limit errors.

For information on other limits, see Limits.

**Examples:**

Example 1 (ts):
```ts
import { query } from "./_generated/server";import { v } from "convex/values";// Return the last 100 tasks in a given task list.export const getTaskList = query({  args: { taskListId: v.id("taskLists") },  handler: async (ctx, args) => {    const tasks = await ctx.db      .query("tasks")      .filter((q) => q.eq(q.field("taskListId"), args.taskListId))      .order("desc")      .take(100);    return tasks;  },});
```

Example 2 (ts):
```ts
// This function will be referred to as `api.myFunctions.myQuery`.export const myQuery = …;// This function will be referred to as `api.myFunctions.sum`.export const sum = …;
```

Example 3 (ts):
```ts
// This function will be referred to as `api.foo.myQueries.listMessages`.export const listMessages = …;
```

Example 4 (ts):
```ts
// This function will be referred to as `api.myFunctions.default`.export default …;
```

---

## Storing Generated Files

**URL:** https://docs.convex.dev/file-storage/store-files

**Contents:**
- Storing Generated Files
- Storing files in actions​

Files can be uploaded to Convex from a client and stored directly, see Upload.

Alternatively files can also be stored after they've been fetched or generated in actions and HTTP actions. For example you might call a third-party API to generate an image based on a user prompt and then store that image in Convex.

Example: Dall-E Storage & Action

Storing files in actions is similar to uploading a file via an HTTP action.

The action takes these steps:

Storage IDs correspond to documents in the "_storage" system table (see Metadata), so they can be validated using the v.id("_storage") validator and typed as Id<"_storage"> in TypeScript.

**Examples:**

Example 1 (ts):
```ts
import { action, internalMutation, query } from "./_generated/server";import { internal } from "./_generated/api";import { v } from "convex/values";import { Id } from "./_generated/dataModel";export const generateAndStore = action({  args: { prompt: v.string() },  handler: async (ctx, args) => {    // Not shown: generate imageUrl from `prompt`    const imageUrl = "https://....";    // Download the image    const response = await fetch(imageUrl);    const image = await response.blob();    // Store the image in Convex    const storageId: Id<"_storage"> = await ctx.storage.store(image);    // Write `storageId` to a document    await ctx.runMutation(internal.images.storeResult, {      storageId,      prompt: args.prompt,    });  },});export const storeResult = internalMutation({  args: {    storageId: v.id("_storage"),    prompt: v.string(),  },  handler: async (ctx, args) => {    const { storageId, prompt } = args;    await ctx.db.insert("images", { storageId, prompt });  },});
```

---

## Optimistic Updates

**URL:** https://docs.convex.dev/using/optimistic-updates

**Contents:**
- Optimistic Updates
- Simple example​
- Complex example​
- Learning more​

Even though Convex queries are completely reactive, sometimes you'll want to update your UI before the mutation changes propagate back to the client. To accomplish this, you can configure an optimistic update to execute as part of your mutation.

Optimistic updates are temporary, local changes to your query results which are used to make your app more responsive. These updates are made by functions registered on a mutation invocation with the .withOptimisticUpdate configuration option.

Optimistic updates are run when a mutation is initiated, rerun if the local query results change, and rolled back when a mutation completes.

Here is how an optimistic update could be added to an increment mutation in a simple counter app:

Optimistic updates receive a localStore, a view of the Convex client's internal state, followed by the arguments to the mutation.

This optimistic update updates the api.counter.get query to be increment higher if it's loaded.

If we want to add an optimistic update to a multi-channel chat app, that might look like:

This optimistic update changes the api.messages.list query for the current channel to include a new message. The newly created message object should match the structure of the real messages generated by the api.messages.list query on the server.

Because this message includes the client's current time (not the server's), it will inevitably not match the api.messages.list query after the mutation runs. That's okay! The Convex client will handle rolling back this update after the mutation completes and the queries are updated. If there are small mistakes in optimistic updates, the UI will always eventually render the correct values.

Similarly, the update creates a temporary Id with new Id("messages", crypto.randomUUID()). This will also be rolled back and replaced with the true ID once the server assigns it.

Lastly, note that this update creates a new array of messages instead of using existingMessages.push(newMessage). This is important! Mutating objects inside of optimistic updates will corrupt the client's internal state and lead to surprising results. Always create new objects inside of optimistic updates.

To learn more, check out our API documentation:

If you'd like some hands on experience, try adding optimistic updates to the tutorial app! If you do, you should notice the app feels snappier — just a little, Convex is pretty fast already! — but otherwise works the same.

To explore even further, try inserting a mistake into this update! You should see a flicker as the optimistic update is applied and then rolled back.

**Examples:**

Example 1 (tsx):
```tsx
import { api } from "../convex/_generated/api";import { useMutation } from "convex/react";export function IncrementCounter() {  const increment = useMutation(api.counter.increment).withOptimisticUpdate(    (localStore, args) => {      const { increment } = args;      const currentValue = localStore.getQuery(api.counter.get);      if (currentValue !== undefined) {        localStore.setQuery(api.counter.get, {}, currentValue + increment);      }    },  );  const incrementCounter = () => {    increment({ increment: 1 });  };  return <button onClick={incrementCounter}>+1</button>;}
```

Example 2 (tsx):
```tsx
import { api } from "../convex/_generated/api";import { useMutation } from "convex/react";import { Id } from "../convex/_generated/dataModel";export function MessageSender(props: { channel: Id<"channels"> }) {  const sendMessage = useMutation(api.messages.send).withOptimisticUpdate(    (localStore, args) => {      const { channel, body } = args;      const existingMessages = localStore.getQuery(api.messages.list, {        channel,      });      // If we've loaded the api.messages.list query, push an optimistic message      // onto the list.      if (existingMessages !== undefined) {        const now = Date.now();        const newMessage = {          _id: crypto.randomUUID() as Id<"messages">,          _creationTime: now,          channel,          body,        };        localStore.setQuery(api.messages.list, { channel }, [          ...existingMessages,          newMessage,        ]);      }    },  );  async function handleSendMessage(    channelId: Id<"channels">,    newMessageText: string,  ) {    await sendMessage({ channel: channelId, body: newMessageText });  }  return (    <button onClick={() => handleSendMessage(props.channel, "Hello world!")}>      Send message    </button>  );}
```

---

## Data

**URL:** https://docs.convex.dev/dashboard/deployments/data/

**Contents:**
- Data
- Filtering documents​
- Writing custom queries​
- Creating tables​
- Creating documents​
- Quick actions (context menu)​
- Editing a cell​
- Editing a document​
- Adding references to other documents​
- Bulk editing documents​

The data page allows you to view and manage all of your tables and documents.

On the left side of the page is a list of your tables. Clicking on a table will allows you to create, view, update, and delete documents in that table.

You may drag-and-drop the column headers in each table to visually re-order the data.

A readonly view of the data page is available in the command line.

You may filters documents on the data page by clicking the "Filter" button on the top of the page.

All fields in a document are filterable by the operations supported in Convex query syntax. Equality and comparisons share the same rules when filtering in the dashboard as a query using the Convex client. You may also filter based on the type of the field.

To add a filter, click the + next to an existing filter. If you add more than one condition, they will be evaluated using the and operation.

For each filter, you must select a field to filter by, operation, and comparison value. In the third input box (selecting a value), you may enter a valid Convex value, such as "a string", 123, or even a complex object, such as { a: { b: 2 } }

When filtering by _creationTime, a date picker will be displayed instead of the normal JavaScript syntax input box. Comparisons for _creationTime are made at the nanosecond granularity, so if you'd like to filter to an exact time, try adding two filter conditions for creationTime >= $time and creationTime <= $time + 1 minute.

You can write a query directly in the dashboard. This allows you to perform arbitrary filtering and transformation of the data, including sorting, joins, grouping and aggregations.

In the ⋮ overflow menu at the top of the data page click on the “Custom query” option.

This opens the same UI used for running your deployed functions, but with the “Custom test query” option selected, which lets you edit the source code for the query. This source code will be sent to your deployment and executed when you click on the “Run Custom Query“ button.

If you're not on the data page, you can still open this UI via the persistent fn button shown on the bottom right of all deployment pages. The keyboard shortcut to open the function runner is Ctrl + ` (backtick).

You may create a table from the dashboard by clicking the "Create Table" button and entering a new name for the table.

You may add individual documents to the table using the “Add Documents” button located in the data table's toolbar.

Once you click “Add Documents” a side panel will open, allowing you to add new documents to your table using JavaScript syntax. To add more than one document add a time, add new objects to the array in the editor.

You can right-click on a document or value to open a context menu with quick actions, like copying values, quickly filtering by the selected value, and deleting documents.

To edit a cell's value, double-click on the cell in the data table, or press the Enter key while it’s selected. You can change the selected cell by using the arrow keys.

You can change the value by editing inline, and pressing enter to save.

You can even edit the type of your value here, as long as it satisfies your schema — try replacing a string with an object!

To edit multiple fields in a document at the same time, hover over the document and right-click to open the context menu. From there you can click on "Edit Document".

To reference another document, use the string ID of the document you want to reference.

You can copy the ID by clicking on its cell and pressing CTRL/CMD+C.

You can edit multiple or all documents at once. To select all documents click on the checkbox in the table header row. To select individual documents hover over the left-most cell and click the checkbox that appears. To select multiple adjacent documents at once, press the Shift key when clicking on the checkbox.

When at least one document is selected, the “(Bulk) Edit Document(s)” button will be visible in the table toolbar. Click the button and an editor will appear on the right hand side.

When at least one document is selected (see above), the “Delete Document(s)” button will be visible in the table toolbar. Click the button to delete documents. If you're editing data in a production deployment a confirmation dialog will appear before the documents are deleted.

You can also delete all documents by clicking on the ⋮ overflow menu at the top of the data page and clicking "Clear Table". This action will delete all documents in the table, without deleting the table itself.

In production environments, the Convex dashboard will have you type in the name of the table before deletion.

Deleting a table is irreversible. In production environments, the Convex dashboard will have you type in the name of the table before deletion.

The "Delete table" button can be found by clicking on the ⋮ overflow menu at the top of the data page. This action will delete all documents this table, and remove the table from your list of tables. If this table had indexes, you will need to redeploy your convex functions (by running npx convex deploy or npx convex dev for production or development, respectively) to recreate the indexes.

At the bottom-left of the page is a "Generate Schema" button which you can click to have Convex generate a schema of all your documents within this table.

The "Schema" button can be found by clicking on the ⋮ overflow menu at the top of the data page.

This button will open a panel showing the saved and generated schemas associated with the selected table.

The "Indexes" button can be found by clicking on the ⋮ overflow menu at the top of the data page.

This button will open a panel showing the indexes associated with the selected table.

Indexes that have not completed backfilling will be accompanied by a loading spinner next to their name.

**Examples:**

Example 1 (sh):
```sh
npx convex data [table]
```

---

## TypeScript

**URL:** https://docs.convex.dev/understanding/best-practices/typescript

**Contents:**
- TypeScript
- Writing Convex functions in TypeScript​
- Adding a schema​
- Type annotating server-side helpers​
  - Inferring types from validators​
  - Document types without system fields​
- Writing frontend code in TypeScript​
  - Type annotating client-side code​
    - Using inferred function return types​
- Turning strings into valid document IDs​

Convex provides end-to-end type support when Convex functions are written in TypeScript.

You can gradually add TypeScript to a Convex project: the following steps provide progressively better type support. For the best support you'll want to complete them all.

Example: TypeScript and Schema

The first step to improving type support in a Convex project is to writing your Convex functions in TypeScript by using the .ts extension.

If you are using argument validation, Convex will infer the types of your functions arguments automatically:

Otherwise you can annotate the arguments type manually:

This can be useful for internal functions accepting complicated types.

If TypeScript is installed in your project npx convex dev and npx convex deploy will typecheck Convex functions before sending code to the Convex backend.

Convex functions are typechecked with the tsconfig.json in the Convex folder: you can modify some parts of this file to change typechecking settings, or delete this file to disable this typecheck.

You'll find most database methods have a return type of Promise<any> until you add a schema.

Once you define a schema the type signature of database methods will be known. You'll also be able to use types imported from convex/_generated/dataModel in both Convex functions and clients written in TypeScript (React, React Native, Node.js etc.).

The types of documents in tables can be described using the Doc type from the generated data model and references to documents can be described with parametrized Document IDs.

When you want to reuse logic across Convex functions you'll want to define helper TypeScript functions, and these might need some of the provided context, to access the database, authentication and any other Convex feature.

Convex generates types corresponding to documents and IDs in your database, Doc and Id, as well as QueryCtx, MutationCtx and ActionCtx types based on your schema and declared Convex functions:

Validators can be reused between argument validation and schema validation. You can use the provided Infer type to get a TypeScript type corresponding to a validator:

All documents in Convex include the built-in _id and _creationTime fields, and so does the generated Doc type. When creating or updating a document you might want use the type without the system fields. Convex provides WithoutSystemFields for this purpose:

All Convex JavaScript clients, including React hooks like useQuery and useMutation provide end to end type safety by ensuring that arguments and return values match the corresponding Convex functions declarations. For React, install and configure TypeScript so you can write your React components in .tsx files instead of .jsx files.

Follow our React or Next.js quickstart to get started with Convex and TypeScript.

When you want to pass the result of calling a function around your client codebase, you can use the generated types Doc and Id, just like on the backend:

You can also declare custom types inside your backend codebase which include Docs and Ids, and import them in your client-side code.

You can also use WithoutSystemFields and any types inferred from validators via Infer.

Sometimes you might want to annotate a type on the client based on whatever your backend function returns. Beside manually declaring the type (on the backend or on the frontend), you can use the generic FunctionReturnType and UsePaginatedQueryReturnType types with a function reference:

Convex requires TypeScript version 5.0.3 or newer.

**Examples:**

Example 1 (ts):
```ts
import { mutation } from "./_generated/server";import { v } from "convex/values";export default mutation({  args: {    body: v.string(),    author: v.string(),  },  // Convex knows that the argument type is `{body: string, author: string}`.  handler: async (ctx, args) => {    const { body, author } = args;    await ctx.db.insert("messages", { body, author });  },});
```

Example 2 (ts):
```ts
import { internalMutation } from "./_generated/server";export default internalMutation({  // To convert this function from JavaScript to  // TypeScript you annotate the type of the arguments object.  handler: async (ctx, args: { body: string; author: string }) => {    const { body, author } = args;    await ctx.db.insert("messages", { body, author });  },});
```

Example 3 (ts):
```ts
import { query } from "./_generated/server";export const list = query({  args: {},  // The inferred return type of `handler` is now `Promise<Doc<"messages">[]>`  handler: (ctx) => {    return ctx.db.query("messages").collect();  },});
```

Example 4 (ts):
```ts
// Types based on your schemaimport { Doc, Id } from "./_generated/dataModel";// Types based on your schema and declared functionsimport {  QueryCtx,  MutationCtx,  ActionCtx,  DatabaseReader,  DatabaseWriter,} from "./_generated/server";// Types that don't depend on schema or functionimport {  Auth,  StorageReader,  StorageWriter,  StorageActionWriter,} from "convex/server";// Note that a `MutationCtx` also satisfies the `QueryCtx` interfaceexport function myReadHelper(ctx: QueryCtx, id: Id<"channels">) {  /* ... */}export function myActionHelper(ctx: ActionCtx, doc: Doc<"messages">) {  /* ... */}
```

---

## Custom OIDC Provider

**URL:** https://docs.convex.dev/auth/advanced/custom-auth

**Contents:**
- Custom OIDC Provider
- Server-side integration​
- Client-side integration​
  - Integrating a new identity provider​
  - Using the new provider​
  - Debugging​

Note: This is an advanced feature! We recommend sticking with the supported third-party authentication providers.

Convex can be integrated with any identity provider supporting the OpenID Connect protocol. At minimum this means that the provider can issue ID tokens and exposes the corresponding JWKS. The ID token is passed from the client to your Convex backend which ensures that the token is valid and enables you to query the user information embedded in the token, as described in Auth in Functions.

Just like with Clerk and Auth0, the backend needs to be aware of the domain of the Issuer and your application's specific applicationID for a given identity provider.

Add these to your convex/auth.config.ts file:

The applicationID property must exactly match the aud field of your JWT and the domain property must exactly match the iss field of the JWT. Use a tool like jwt.io to view an JWT and confirm these fields match exactly.

If multiple providers are provided, the first one fulfilling the above criteria will be used.

If you're not able to obtain tokens with an aud field, you'll need to instead configure a Custom JWT. If you're not sure if your token is an OIDC ID token, check the spec for a list of all required fields.

OIDC requires the routes ${domain}/.well-known/jwks.json and ${domain}/.well-known/openid-configuration. domain may include a path like https://your.issuer.url.com/api/auth. This isn't common for third party auth providers but may be useful if you're implementing OIDC on your own server.

The ConvexProviderWithAuth component provides a convenient abstraction for building an auth integration similar to the ones Convex provides for Clerk and Auth0.

In the following example we build an integration with an imaginary "ProviderX", whose React integration includes AuthProviderXReactProvider and useProviderXAuth hook.

First we replace ConvexProvider with AuthProviderXReactProvider wrapping ConvexProviderWithAuth at the root of our app:

All we really need is to implement the useAuthFromProviderX hook which gets passed to the ConvexProviderWithAuth component.

This useAuthFromProviderX hook provides a translation between the auth provider API and the ConvexReactClient API, which is ultimately responsible for making sure that the ID token is passed down to your Convex backend.

If you successfully follow the steps above you can now use the standard Convex utilities for checking the authentication state: the useConvexAuth() hook and the Authenticated, Unauthenticated and AuthLoading helper components.

See Debugging Authentication.

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      domain: "https://your.issuer.url.com",      applicationID: "your-application-id",    },  ],} satisfies AuthConfig;
```

Example 2 (jsx):
```jsx
import { AuthProviderXReactProvider } from "providerX";import { ConvexProviderWithAuth } from "convex/react";root.render(  <StrictMode>    <AuthProviderXReactProvider>      <ConvexProviderWithAuth client={convex} useAuth={useAuthFromProviderX}>        <App />      </ConvexProviderWithAuth>    </AuthProviderXReactProvider>  </StrictMode>,);
```

Example 3 (jsx):
```jsx
function useAuthFromProviderX() {  const { isLoading, isAuthenticated, getToken } = useProviderXAuth();  const fetchAccessToken = useCallback(    async ({ forceRefreshToken }) => {      // Here you can do whatever transformation to get the ID Token      // or null      // Make sure to fetch a new token when `forceRefreshToken` is true      return await getToken({ ignoreCache: forceRefreshToken });    },    // If `getToken` isn't correctly memoized    // remove it from this dependency array    [getToken],  );  return useMemo(    () => ({      // Whether the auth provider is in a loading state      isLoading: isLoading,      // Whether the auth provider has the user signed in      isAuthenticated: isAuthenticated ?? false,      // The async function to fetch the ID token      fetchAccessToken,    }),    [isLoading, isAuthenticated, fetchAccessToken],  );}
```

---

## Projects

**URL:** https://docs.convex.dev/dashboard/projects

**Contents:**
- Projects
- Creating a project​
- Project Settings​
- Deleting projects​

A project corresponds to a codebase that uses Convex, which contains a production deployment and one personal deployment for each team member.

Clicking on a project in the landing page will redirect you to project details.

Projects can be created from the dashboard or from the CLI. To create a project from the dashboard click on the Create Project button.

You can access project-level settings by clicking on the triple-dot ⋮ button on each Project card on the Projects page.

On the Project Settings page, you can:

To delete a project, click on the triple-dot ⋮ button on the Project card and select "Delete". You may also delete your project from the Project Settings page.

Once a project is deleted, it cannot be recovered. All deployments and data associated with the project will be permanently removed. When deleting a project from the dashboard, you will be asked to confirm the deletion. Projects with activity in the production deployment will have additional confirmation steps to prevent accidental deletion.

---

## Auth in Functions

**URL:** https://docs.convex.dev/auth/functions-auth

**Contents:**
- Auth in Functions
- User identity fields​
  - Clerk claims configuration​
  - Custom JWT Auth​
- HTTP Actions​

If you're using Convex Auth, see the authorization doc.

Within a Convex function, you can access information about the currently logged-in user by using the auth property of the QueryCtx, MutationCtx, or ActionCtx object:

The UserIdentity object returned by getUserIdentity is guaranteed to have tokenIdentifier, subject and issuer fields. Which other fields it will include depends on the identity provider used and the configuration of JWT tokens and OpenID scopes.

tokenIdentifier is a combination of subject and issuer to ensure uniqueness even when multiple providers are used.

If you followed one of our integrations with Clerk or Auth0 at least the following fields will be present: familyName, givenName, nickname, pictureUrl, updatedAt, email, emailVerified. See their corresponding standard definition in the OpenID docs.

If you're using Clerk, the fields returned by getUserIdentity are determined by your JWT template's Claims config. If you've set custom claims, they will be returned by getUserIdentity as well.

If you're using Custom JWT auth instead of OpenID standard fields you'll find each nested field available at dot-containing-string field names like identity["properties.email"].

You can also access the user identity from an HTTP action ctx.auth.getUserIdentity(), by calling your endpoint with an Authorization header including a JWT token:

**Examples:**

Example 1 (ts):
```ts
import { mutation } from "./_generated/server";export const myMutation = mutation({  args: {    // ...  },  handler: async (ctx, args) => {    const identity = await ctx.auth.getUserIdentity();    if (identity === null) {      throw new Error("Unauthenticated call to mutation");    }    //...  },});
```

Example 2 (ts):
```ts
import { mutation } from "./_generated/server";export const myMutation = mutation({  args: {    // ...  },  handler: async (ctx, args) => {    const identity = await ctx.auth.getUserIdentity();    const { tokenIdentifier, name, email } = identity!;    //...  },});
```

Example 3 (ts):
```ts
const jwtToken = "...";fetch("https://<deployment name>.convex.site/myAction", {  headers: {    Authorization: `Bearer ${jwtToken}`,  },});
```

---

## Accessing File Metadata

**URL:** https://docs.convex.dev/file-storage/file-metadata

**Contents:**
- Accessing File Metadata
- Accessing metadata from actions (deprecated)​

Every stored file is reflected as a document in the "_storage" system table. File metadata of a file can be accessed from queries and mutations via db.system.get and db.system.query:

This is an example of the returned document:

The returned document has the following fields:

You can check the metadata manually on your dashboard.

Alternatively, a storage.getMetadata() function is available to access individual file metadata from actions and HTTP actions:

Note that storage.getMetadata() returns a FileMetadata, which has a slightly different shape than the result from db.system.get.

**Examples:**

Example 1 (ts):
```ts
import { v } from "convex/values";import { query } from "./_generated/server";export const getMetadata = query({  args: {    storageId: v.id("_storage"),  },  handler: async (ctx, args) => {    return await ctx.db.system.get(args.storageId);  },});export const listAllFiles = query({  handler: async (ctx) => {    // You can use .paginate() as well    return await ctx.db.system.query("_storage").collect();  },});
```

Example 2 (json):
```json
{  "_creationTime": 1700697415295.742,  "_id": "3k7ty84apk2zy00ay4st1n5p9kh7tf8",  "contentType": "image/jpeg",  "sha256": "cb58f529b2ed5a1b8b6681d91126265e919ac61fff6a367b8341c0f46b06a5bd",  "size": 125338}
```

Example 3 (ts):
```ts
import { v } from "convex/values";import { action } from "./_generated/server";export const getMetadata = action({  args: { storageId: v.id("_storage") },  handler: async (ctx, args) => {    return await ctx.storage.getMetadata(args.storageId);  },});
```

---

## Convex & Clerk

**URL:** https://docs.convex.dev/auth/clerk

**Contents:**
- Convex & Clerk
- Get started​
  - React​
  - Next.js​
  - Tanstack Start​
- Next steps​
  - Accessing user information in functions​
  - Accessing user information client-side​
- Configuring dev and prod instances​
  - Configuring the backend​

Clerk is an authentication platform providing login via passwords, social identity providers, one-time email or SMS access codes, and multi-factor authentication and user management.

Convex offers a provider that is specifically for integrating with Clerk called <ConvexProviderWithClerk>. It works with any of Clerk's React-based SDKs, such as the Next.js and Expo SDKs.

See the following sections for the Clerk SDK that you're using:

Example: React with Convex and Clerk

This guide assumes you already have a working React app with Convex. If not follow the Convex React Quickstart first. Then:

Sign up for a free Clerk account at clerk.com/sign-up.

Choose how you want your users to sign in.

In the Clerk Dashboard, navigate to the JWT templates page.

Select New template and then from the list of templates, select Convex. You'll be redirected to the template's settings page. Do NOT rename the JWT token. It must be called convex.

Copy and save the Issuer URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your Clerk app's Frontend API URL. In development, it's format will be https://verb-noun-00.clerk.accounts.dev. In production, it's format will be https://clerk.<your-domain>.com.

In your app's convex folder, create a new file auth.config.ts with the following code. This is the server-side configuration for validating access tokens.

Run npx convex dev to automatically sync your configuration to your backend.

In a new terminal window, install the Clerk React SDK:

In the Clerk Dashboard, navigate to the API keys page. In the Quick Copy section, copy your Clerk Publishable Key and set it as the CLERK_PUBLISHABLE_KEY environment variable. If you're using Vite, you will need to prefix it with VITE_.

Both Clerk and Convex have provider components that are required to provide authentication and client context.

You should already have <ConvexProvider> wrapping your app. Replace it with <ConvexProviderWithClerk>, and pass Clerk's useAuth() hook to it.

Then, wrap it with <ClerkProvider>. <ClerkProvider> requires a publishableKey prop, which you can set to the VITE_CLERK_PUBLISHABLE_KEY environment variable.

You can control which UI is shown when the user is signed in or signed out using Convex's <Authenticated>, <Unauthenticated> and <AuthLoading> helper components. These should be used instead of Clerk's <SignedIn>, <SignedOut> and <ClerkLoading> components, respectively.

It's important to use the useConvexAuth() hook instead of Clerk's useAuth() hook when you need to check whether the user is logged in or not. The useConvexAuth() hook makes sure that the browser has fetched the auth token needed to make authenticated requests to your Convex backend, and that the Convex backend has validated it.

In the following example, the <Content /> component is a child of <Authenticated>, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.

If the client is authenticated, you can access the information stored in the JWT via ctx.auth.getUserIdentity.

If the client isn't authenticated, ctx.auth.getUserIdentity will return null.

Make sure that the component calling this query is a child of <Authenticated> from convex/react. Otherwise, it will throw on page load.

Example: Next.js with Convex and Clerk

This guide assumes you already have a working Next.js app with Convex. If not follow the Convex Next.js Quickstart first. Then:

Sign up for a free Clerk account at clerk.com/sign-up.

Choose how you want your users to sign in.

In the Clerk Dashboard, navigate to the JWT templates page.

Select New template and then from the list of templates, select Convex. You'll be redirected to the template's settings page. Do NOT rename the JWT token. It must be called convex.

Copy and save the Issuer URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your Clerk app's Frontend API URL. In development, it's format will be https://verb-noun-00.clerk.accounts.dev. In production, it's format will be https://clerk.<your-domain>.com.

In your app's convex folder, create a new file auth.config.ts with the following code. This is the server-side configuration for validating access tokens.

Run npx convex dev to automatically sync your configuration to your backend.

In a new terminal window, install the Clerk Next.js SDK:

In the Clerk Dashboard, navigate to the API keys page. In the Quick Copy section, copy your Clerk Publishable and Secret Keys and set them as the NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY and CLERK_SECRET_KEY environment variables, respectively.

Clerk's clerkMiddleware() helper grants you access to user authentication state throughout your app.

Create a middleware.ts file.

In your middleware.ts file, export the clerkMiddleware() helper:

By default, clerkMiddleware() will not protect any routes. All routes are public and you must opt-in to protection for routes.https://clerk.com/docs/references/nextjs/clerk-middleware) to learn how to require authentication for specific routes.

Both Clerk and Convex have provider components that are required to provide authentication and client context.

Typically, you'd replace <ConvexProvider> with <ConvexProviderWithClerk>, but with Next.js App Router, things are a bit more complex.

<ConvexProviderWithClerk> calls ConvexReactClient() to get Convex's client, so it must be used in a Client Component. Your app/layout.tsx, where you would use <ConvexProviderWithClerk>, is a Server Component, and a Server Component cannot contain Client Component code. To solve this, you must first create a wrapper Client Component around <ConvexProviderWithClerk>.

Now, your Server Component, app/layout.tsx, can render <ConvexClientProvider> instead of rendering <ConvexProviderWithClerk> directly. It's important that <ClerkProvider> wraps <ConvexClientProvider>, and not the other way around, as Convex needs to be able to access the Clerk context.

You can control which UI is shown when the user is signed in or signed out using Convex's <Authenticated>, <Unauthenticated> and <AuthLoading> helper components. These should be used instead of Clerk's <SignedIn>, <SignedOut> and <ClerkLoading> components, respectively.

It's important to use the useConvexAuth() hook instead of Clerk's useAuth() hook when you need to check whether the user is logged in or not. The useConvexAuth() hook makes sure that the browser has fetched the auth token needed to make authenticated requests to your Convex backend, and that the Convex backend has validated it.

In the following example, the <Content /> component is a child of <Authenticated>, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.

If the client is authenticated, you can access the information stored in the JWT via ctx.auth.getUserIdentity.

If the client isn't authenticated, ctx.auth.getUserIdentity will return null.

Make sure that the component calling this query is a child of <Authenticated> from convex/react. Otherwise, it will throw on page load.

Example: Tanstack Start with Convex and Clerk

See the Tanstack Start with Clerk guide for more information.

See Auth in Functions to learn about how to access information about the authenticated user in your queries, mutations and actions.

See Storing Users in the Convex Database to learn about how to store user information in the Convex database.

To access the authenticated user's information, use Clerk's User object, which can be accessed using Clerk's useUser() hook. For more information on the User object, see the Clerk docs.

To configure a different Clerk instance between your Convex development and production deployments, you can use environment variables configured on the Convex dashboard.

In the Clerk Dashboard, navigate to the API keys page. Copy your Clerk Frontend API URL. This URL is the issuer domain for Clerk's JWT templates, and is necessary for Convex to validate access tokens. In development, it's format will be https://verb-noun-00.clerk.accounts.dev. In production, it's format will be https://clerk.<your-domain>.com.

Paste your Clerk Frontend API URL into your .env file, set it as the CLERK_JWT_ISSUER_DOMAIN environment variable.

Then, update your auth.config.ts file to use the environment variable.

Development configuration

In the left sidenav of the Convex dashboard, switch to your development deployment and set the values for your development Clerk instance.

Then, to switch your deployment to the new configuration, run npx convex dev.

Production configuration

In the left sidenav of the Convex dashboard, switch to your production deployment and set the values for your production Clerk instance.

Then, to switch your deployment to the new configuration, run npx convex deploy.

Clerk's API keys differ depending on whether they are for development or production. Don't forget to update the environment variables in your .env file as well as your hosting platform, such as Vercel or Netlify.

Development configuration

Clerk's Publishable Key for development follows the format pk_test_....

Production configuration

Clerk's Publishable Key for production follows the format pk_live_....

If a user goes through the Clerk login flow successfully, and after being redirected back to your page, useConvexAuth() returns isAuthenticated: false, it's possible that your backend isn't correctly configured.

The auth.config.ts file contains a list of configured authentication providers. You must run npx convex dev or npx convex deploy after adding a new provider to sync the configuration to your backend.

For more thorough debugging steps, see Debugging Authentication.

The authentication flow looks like this under the hood:

ConvexProviderWithClerk takes care of refetching the token when needed to make sure the user stays authenticated with your backend.

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      // Replace with your own Clerk Issuer URL from your "convex" JWT template      // or with `process.env.CLERK_JWT_ISSUER_DOMAIN`      // and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard      // See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances      domain: process.env.CLERK_JWT_ISSUER_DOMAIN!,      applicationID: "convex",    },  ]} satisfies AuthConfig;
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (sh):
```sh
npm install @clerk/clerk-react
```

Example 4 (env):
```env
VITE_CLERK_PUBLISHABLE_KEY=YOUR_PUBLISHABLE_KEY
```

---

## All articles

**URL:** https://stack.convex.dev/articles

---

## Dashboard

**URL:** https://docs.convex.dev/dashboard

**Contents:**
- Dashboard

The dashboard is the central hub for managing your Convex projects. Here you can create and manage your Convex teams, projects, and deployments.

---

## Indexes

**URL:** https://docs.convex.dev/using/indexes

**Contents:**
- Indexes
- Defining indexes​
- Querying documents using indexes​
- Sorting with indexes​
- Staged indexes​
- Limits​

Indexes are a data structure that allow you to speed up your document queries by telling Convex how to organize your documents. Indexes also allow you to change the order of documents in query results.

For a more in-depth introduction to indexing see Indexes and Query Performance.

Indexes are defined as part of your Convex schema. Each index consists of:

To add an index onto a table, use the index method on your table's schema:

The by_channel index is ordered by the channel field defined in the schema. For messages in the same channel, they are ordered by the system-generated _creationTime field which is added to all indexes automatically.

By contrast, the by_channel_user index orders messages in the same channel by the user who sent them, and only then by _creationTime.

Indexes are created in npx convex dev and npx convex deploy.

You may notice that the first deploy that defines an index is a bit slower than normal. This is because Convex needs to backfill your index. The more data in your table, the longer it will take Convex to organize it in index order. If you need to add indexes to large tables, use a staged index.

You can feel free to query an index in the same deploy that defines it. Convex will ensure that the index is backfilled before the new query and mutation functions are registered.

In addition to adding new indexes, npx convex deploy will delete indexes that are no longer present in your schema. Make sure that your indexes are completely unused before removing them from your schema!

A query for "messages in channel created 1-2 minutes ago" over the by_channel index would look like:

The .withIndex method defines which index to query and how Convex will use that index to select documents. The first argument is the name of the index and the second is an index range expression. An index range expression is a description of which documents Convex should consider when running the query.

The choice of index both affects how you write the index range expression and what order the results are returned in. For instance, by making both a by_channel and by_channel_user index, we can get results within a channel ordered by _creationTime or by user, respectively. If you were to use the by_channel_user index like this:

The results would be all of the messages in a channel ordered by user, then by _creationTime. If you were to use by_channel_user like this:

The results would be the messages in the given channel sent by user, ordered by _creationTime.

An index range expression is always a chained list of:

You must step through fields in index order.

Each equality expression must compare a different index field, starting from the beginning and in order. The upper and lower bounds must follow the equality expressions and compare the next field.

For example, it is not possible to write a query like:

This query is invalid because the by_channel index is ordered by (channel, _creationTime) and this query range has a comparison on _creationTime without first restricting the range to a single channel. Because the index is sorted first by channel and then by _creationTime, it isn't a useful index for finding messages in all channels created 1-2 minutes ago. The TypeScript types within withIndex will guide you through this.

To better understand what queries can be run over which indexes, see Introduction to Indexes and Query Performance.

The performance of your query is based on the specificity of the range.

For example, if the query is

then query's performance would be based on the number of messages in channel created 1-2 minutes ago.

If the index range is not specified, all documents in the index will be considered in the query.

For performance, define index ranges that are as specific as possible! If you are querying a large table and you're unable to add any equality conditions with .eq, you should consider defining a new index.

.withIndex is designed to only allow you to specify ranges that Convex can efficiently use your index to find. For all other filtering you can use the .filter method.

For example to query for "messages in channel not created by me" you could do:

In this case the performance of this query will be based on how many messages are in the channel. Convex will consider each message in the channel and only return the messages where the user field matches myUserId.

Queries that use withIndex are ordered by the columns specified in the index.

The order of the columns in the index dictates the priority for sorting. The values of the columns listed first in the index are compared first. Subsequent columns are only compared as tie breakers only if all earlier columns match.

Since Convex automatically includes _creationTime as the last column in all indexes, _creationTime will always be the final tie breaker if all other columns in the index are equal.

For example, by_channel_user includes channel, user, and \_creationTime. So queries on messages that use .withIndex("by_channel_user") will be sorted first by channel, then by user within each channel, and finally by the creation time.

Sorting with indexes allows you to satisfy use cases like displaying the top N scoring users, the most recent N transactions, or the most N liked messages.

For example, to get the top 10 highest scoring players in your game, you might define an index on the player's highest score:

You can then efficiently find the top 10 highest scoring players using your index and take(10):

In this example, the range expression is omitted because we're looking for the highest scoring players of all time. This particular query is reasonably efficient for large data sets only because we're using take().

If you use an index without a range expression, you should always use one of the following in conjunction with withIndex:

These APIs allow you to efficiently limit your query to a reasonable size without performing a full table scan.

When your query fetches documents from the database, it will scan the rows in the range you specify. If you are using .collect(), for instance, it will scan all of the rows in the range. So if you use withIndex without a range expression, you will be scanning the whole table, which can be slow when your table has thousands of rows. .filter() doesn't affect which documents are scanned. Using .first() or .unique() or .take(n) will only scan rows until it has enough documents.

You can include a range expression to satisfy more targeted queries. For example, to get the top scoring players in Canada, you might use both take() and a range expression:

By default, index creation happens synchronously when you deploy code. For large tables, the process of backfilling the index for the existing table can be slow. Staged indexes are a way to create an index on a large table asynchronously without blocking deploy. This can be useful if you are working on multiple features at once.

To create a staged index, use the following syntax in your schema.ts.

Staged indexes cannot be used in queries until you enable them. To enable them, they must first finish backfilling.

You can check the backfill progress via the Indexes pane on the dashboard data page. Once it is complete, you can enable the index and use it by removing the staged option.

Convex supports indexes containing up to 16 fields. You can define 32 indexes on each table. Indexes can't contain duplicate fields.

No reserved fields (starting with _) are allowed in indexes. The _creationTime field is automatically added to the end of every index to ensure a stable ordering. It should not be added explicitly in the index definition, and it's counted towards the index fields limit.

The by_creation_time index is created automatically (and is what is used in database queries that don't specify an index). The by_id index is reserved.

**Examples:**

Example 1 (ts):
```ts
import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";// Define a messages table with two indexes.export default defineSchema({  messages: defineTable({    channel: v.id("channels"),    body: v.string(),    user: v.id("users"),  })    .index("by_channel", ["channel"])    .index("by_channel_user", ["channel", "user"]),});
```

Example 2 (ts):
```ts
const messages = await ctx.db  .query("messages")  .withIndex("by_channel", (q) =>    q      .eq("channel", channel)      .gt("_creationTime", Date.now() - 2 * 60000)      .lt("_creationTime", Date.now() - 60000),  )  .collect();
```

Example 3 (ts):
```ts
const messages = await ctx.db  .query("messages")  .withIndex("by_channel_user", (q) => q.eq("channel", channel))  .collect();
```

Example 4 (ts):
```ts
const messages = await ctx.db  .query("messages")  .withIndex("by_channel_user", (q) =>    q.eq("channel", channel).eq("user", user),  )  .collect();
```

---

## Runtimes

**URL:** https://docs.convex.dev/functions/runtimes

**Contents:**
- Runtimes
- Default Convex runtime​
  - Supported APIs​
    - Network APIs​
    - Encoding APIs​
    - Web Stream APIs​
    - Web Crypto APIs​
  - Restrictions on queries and mutations​
    - Using randomness and time in queries and mutations​
  - Actions​

Convex functions can run in two runtimes:

All Convex backend functions are written in JavaScript or TypeScript. By default all functions run in a custom JavaScript runtime very similar to the Cloudflare Workers runtime with access to most web standard globals.

The default runtime has many advantages including:

The default runtime supports most npm libraries that work in the browser, Deno, and Cloudflare workers. If your library isn't supported, you can use an action with the Node.js runtime, or reach out in Discord. We are improving support all the time.

Query and mutation functions are further restricted by the runtime to be deterministic. This allows Convex to automatically retry them by the system as necessary.

Determinism means that no matter how many times your function is run, as long as it is given the same arguments, it will have identical side effects and return the same value.

You don't have to think all that much about maintaining these properties of determinism when you write your Convex functions. Convex will provide helpful error messages as you go, so you can't accidentally do something forbidden.

Convex provides a "seeded" strong pseudo-random number generator at Math.random() so that it can guarantee the determinism of your function. The random number generator's seed is an implicit parameter to your function. Multiple calls to Math.random() in one function call will return different random values. Note that Convex does not reevaluate the Javascript modules on every function run, so a call to Math.random() stored in a global variable will not change between function runs.

To ensure the logic within your function is reproducible, the system time used globally (outside of any function) is "frozen" at deploy time, while the system time during Convex function execution is "frozen" when the function begins. Date.now() will return the same result for the entirety of your function's execution. For example,

Actions are unrestricted by the same rules of determinism as query and mutation functions. Notably actions are allowed to call third-party HTTP endpoints via the browser-standard fetch function.

By default actions also run in Convex’s custom JavaScript runtime with all of its advantages including no cold starts and a browser-like API environment. They can also live in the same file as your query and mutation functions.

Some JavaScript and TypeScript libraries use features that are not included in the default Convex runtime. Convex actions provide an escape hatch to Node.js via the "use node" directive at the top of a file that contains your action. Learn more.

Use of the Node.js environment is restricted to action functions only. If you want to use a library designed for Node.js and interact with the Convex database, you need to call the Node.js library from an action, and use runQuery or runMutation helper to call a query or mutation.

Every .ts and .js file in the convex directory is bundled either for the default Convex JavaScript runtime or Node.js, along with any code it imports.

Files with the "use node" directive should not contain any Convex queries or mutations since they cannot be run in the Node.js runtime. Additionally, files without the "use node" directive should not import any files with the "use node" directive. Files that contain no Convex functions, like a convex/utils.ts file, also need the "use node" directive if they use Node.js-specific libraries.

If you encounter bundling errors about Node.js-specific imports like fs / node:fs not being available when deploying convex functions, running npx convex dev --once --debug-node-apis gives more information about these. It uses a slower bundling method to track the train of imports, narrowing down which import is responsible for the error.

Note that argument size limits are lower (5MiB instead of 16MiB).

By default, all actions ran in the Node.js environment are executed in Node.js 18. This version is configurable in the convex.json file. We currently support Node.js 18, 20, and 22.

When pushing a new Node.js version to the server, the new code for your functions may be executed in the old Node.js version for up a few minutes.

Node.js 18 reached its end-of-life on April 30, 2025 and we will no longer support new deployments on it Convex after September 10, 2025. All projects created after this date will be on Node.js 20. All projects that are still on Node.js 18 after October 22, 2025 will automatically be migrated to Node.js 20.

Note: This configuration is not supported when running the self-hosted Convex backend. The node version that is specified in the .nvmrc will be used instead.

**Examples:**

Example 1 (javascript):
```javascript
const globalRand = Math.random(); // `globalRand` does not change between runs.const globalNow = Date.now(); // `globalNow` is the time when Convex functions were deployed.export const updateSomething = mutation({  args: {},  handler: () => {    const now1 = Date.now(); // `now1` is the time when the function execution started.    const rand1 = Math.random(); // `rand1` has a new value for each function run.    // implementation    const now2 = Date.now(); // `now2` === `now1`    const rand2 = Math.random(); // `rand1` !== `rand2`  },});
```

---

## 

**URL:** https://docs.convex.dev/

---

## Logs

**URL:** https://docs.convex.dev/dashboard/deployments/logs

**Contents:**
- Logs
  - Filter logs​
  - Log Types​

The logs page is a realtime view of all activity that occurs within your deployment.

The logs page provides a short history of recent function logs, and will display new logs as they are generated. To store a longer history of logs, you may configure a log stream.

Function activity includes:

In addition to function activity, deployment events describing configuration changes will be present here.

Clicking on log will open a view for all logs associated with the same Request ID as the selected log. This can be useful for debugging errors and understanding the context of a function execution.

You can use controls on the top of this page to filter logs by text, function name, execution status, and log severity.

Use the "Filter logs..." text box on the top of the page to filter log text.

You can use the “Functions” drop-down list to include or exclude functions from the results.

You can also find logs for a particular error using "Filter logs" and the Convex request id. For example if you see this Error in your browser console:

You can view the logs for that function in your dashboard by pasting that Request ID into the 'Search logs...' search bar on the Logs page of your Convex dashboard. Note that because this page is not a complete historical view of logs, you may not find logs for older requests.

Most error reporting services and log sinks should also be searchable by Request ID.

Logs can also be filtered by type. Types include function outcomes (success or failure) and severity levels (info, warn, debug, error).

All failed executions will include a reason, which will usually be a JavaScript exception.

---

## Schedules

**URL:** https://docs.convex.dev/dashboard/deployments/schedules

**Contents:**
- Schedules
- Scheduled functions UI​
- Cron jobs UI​

The schedules page displays all scheduled functions and cron jobs in your deployment. Use the tabs at the top of this page to switch between scheduled functions and cron jobs.

The scheduled functions UI shows a list of all upcoming function invocation. From here, you can filter to scheduled runs for a specific function, and cancel scheduled functions runs.

The cron jobs UI lists all of your cron jobs, including their run frequency and scheduled run time.

Expanding a specific cron job will open the execution history for the selected job.

---

## Mutations

**URL:** https://docs.convex.dev/functions/mutation-functions

**Contents:**
- Mutations
- Mutation names​
- The mutation constructor​
  - Mutation arguments​
  - Mutation responses​
  - Mutation context​
- Splitting up mutation code via helpers​
- Using NPM packages​
- Calling mutations from clients​
- Transactions​

Mutations insert, update and remove data from the database, check authentication or perform other business logic, and optionally return a response to the client application.

This is an example mutation, taking in named arguments, writing data to the database and returning a result:

Read on to understand how to build mutations yourself.

Mutations follow the same naming rules as queries, see Query names.

Queries and mutations can be defined in the same file when using named exports.

To declare a mutation in Convex use the mutation constructor function. Pass it an object with a handler function, which performs the mutation:

Unlike a query, a mutation can but does not have to return a value.

Just like queries, mutations accept named arguments, and the argument values are accessible as fields of the second parameter of the handler function:

Arguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your mutation.

To both declare the types of arguments and to validate them, add an args object using v validators:

See argument validation for the full list of supported types and validators.

The first parameter to the handler function is reserved for the mutation context.

Queries can return values of any supported Convex type which will be automatically serialized and deserialized.

Mutations can also return undefined, which is not a valid Convex value. When a mutation returns undefined it is translated to null on the client.

The mutation constructor enables writing data to the database, and other Convex features by passing a MutationCtx object to the handler function as the first parameter:

Which part of the mutation context is used depends on what your mutation needs to do:

To read from and write to the database use the db field. Note that we make the handler function an async function so we can await the promise returned by db.insert():

Read on about Writing Data.

To generate upload URLs for storing files use the storage field. Read on about File Storage.

To check user authentication use the auth field. Read on about Authentication.

To schedule functions to run in the future, use the scheduler field. Read on about Scheduled Functions.

When you want to split up the code in your mutation or reuse logic across multiple Convex functions you can define and call helper

Mutations can call helpers that take a QueryCtx as argument, since the mutation context can do everything query context can.

You can export helpers to use them across multiple files. They will not be callable from outside of your Convex functions.

See Type annotating server side helpers for more guidance on TypeScript types.

Mutations can import NPM packages installed in node_modules. Not all NPM packages are supported, see Runtimes for more details.

To call a mutation from React use the useMutation hook along with the generated api object.

See the React client documentation for all the ways queries can be called.

When mutations are called from the React or Rust clients, they are executed one at a time in a single, ordered queue. You don't have to worry about mutations editing the database in a different order than they were triggered.

Mutations run transactionally. This means that:

For this to work, similarly to queries, mutations must be deterministic, and cannot call third party APIs. To call third party APIs, use actions.

Mutations have a limit to the amount of data they can read and write at once to guarantee good performance. Learn more in Read/write limit errors.

For information on other limits, see Limits.

**Examples:**

Example 1 (ts):
```ts
import { mutation } from "./_generated/server";import { v } from "convex/values";// Create a new task with the given textexport const createTask = mutation({  args: { text: v.string() },  handler: async (ctx, args) => {    const newTaskId = await ctx.db.insert("tasks", { text: args.text });    return newTaskId;  },});
```

Example 2 (ts):
```ts
import { mutation } from "./_generated/server";export const mutateSomething = mutation({  handler: () => {    // implementation will be here  },});
```

Example 3 (ts):
```ts
import { mutation } from "./_generated/server";export const mutateSomething = mutation({  handler: (_, args: { a: number; b: number }) => {    // do something with `args.a` and `args.b`    // optionally return a value    return "success";  },});
```

Example 4 (ts):
```ts
import { mutation } from "./_generated/server";import { v } from "convex/values";export const mutateSomething = mutation({  args: { a: v.number(), b: v.number() },  handler: (_, args) => {    // do something with `args.a` and `args.b`  },});
```

---

## Vector Search

**URL:** https://docs.convex.dev/search/vector-search

**Contents:**
- Vector Search
- Defining vector indexes​
- Running vector searches​
  - Filter expressions​
  - Other filtering​
  - Ordering​
- Advanced patterns​
  - Using a separate table to store vectors​
  - Fetching results and adding new documents​
- Limits​

Vector search allows you to find Convex documents similar to a provided vector. Typically, vectors will be embeddings which are numerical representations of text, images, or audio.

Embeddings and vector search enable you to provide useful context to LLMs for AI powered applications, recommendations for similar content and more.

Vector search is consistent and fully up-to-date. You can write a vector and immediately read it from a vector search. Unlike full text search, however, vector search is only available in Convex actions.

Example: Vector Search App

To use vector search you need to:

Like database indexes, vector indexes are a data structure that is built in advance to enable efficient querying. Vector indexes are defined as part of your Convex schema.

To add a vector index onto a table, use the vectorIndex method on your table's schema. Every vector index has a unique name and a definition with:

For example, if you want an index that can search for similar foods within a given cuisine, your table definition could look like:

You can specify vector and filter fields on nested documents by using a dot-separated path like properties.name.

Unlike database queries or full text search, vector searches can only be performed in a Convex action.

They generally involve three steps:

Here's an example of the first two steps for searching for similar French foods based on a description:

An example of the first step can be found here in the vector search demo app.

Focusing on the second step, the vectorSearch API takes in the table name, the index name, and finally a VectorSearchQuery object describing the search. This object has the following fields:

It returns an Array of objects containing exactly two fields:

Neither the underlying document nor the vector are included in results, so once you have the list of results, you will want to load the desired information about the results.

There are a few strategies for loading this information documented in the Advanced Patterns section.

For now, let's load the documents and return them from the action. To do so, we'll pass the list of results to a Convex query and run it inside of our action, returning the result:

As mentioned above, vector searches support efficiently filtering results by additional fields on your document using either exact equality on a single field, or an OR of expressions.

For example, here's a filter for foods with cuisine exactly equal to "French":

You can also filter documents by a single field that contains several different values using an or expression. Here's a filter for French or Indonesian dishes:

For indexes with multiple filter fields, you can also use .or() filters on different fields. Here's a filter for dishes whose cuisine is French or whose main ingredient is butter:

Both cuisine and mainIngredient would need to be included in the filterFields in the .vectorIndex definition.

Results can be filtered based on how similar they are to the provided vector using the _score field in your action:

Additional filtering can always be done by passing the vector search results to a query or mutation function that loads the documents and performs filtering using any of the fields on the document.

For performance, always put as many of your filters as possible into .vectorSearch.

Vector queries always return results in relevance order.

Currently Convex searches vectors using an approximate nearest neighbor search based on cosine similarity. Support for more similarity metrics will come in the future.

If multiple documents have the same score, ties are broken by the document ID.

There are two main options for setting up a vector index:

The examples above show the first option, which is simpler and works well for reading small amounts of documents. The second option is more complex, but better supports reading or returning large amounts of documents.

Since vectors are typically large and not useful beyond performing vector searches, it's nice to avoid loading them from the database when reading other data (e.g. db.get()) or returning them from functions by storing them in a separate table.

A table definition for movies, and a vector index supporting search for similar movies filtering by genre would look like this:

Generating an embedding and running a vector search are the same as using a single table. Loading the relevant documents given the vector search result is different since we have an ID for movieEmbeddings but want to load a movies document. We can do this using the by_embedding database index on the movies table:

Returning information from a vector search involves an action (since vector search is only available in actions) and a query or mutation to load the data.

The example above used a query to load data and return it from an action. Since this is an action, the data returned is not reactive. An alternative would be to return the results of the vector search in the action, and have a separate query that reactively loads the data. The search results will not update reactively, but the data about each result would be reactive.

The Vector Search Demo App uses this strategy to show similar movies with a reactive "Votes" count.

Convex supports millions of vectors today. This is an ongoing project and we will continue to scale this offering out with the rest of Convex.

Vector indexes must have:

Vector indexes count towards the limit of 32 indexes per table. In addition you can have up to 4 vector indexes per table.

Vector searches can have:

If your action performs a vector search then passes the results to a query or mutation function, you may find that one or more results from the vector search have been deleted or mutated. Because vector search is only available in actions, you cannot perform additional transactional queries or mutations based on the results. If this is important for your use case, please let us know on Discord!

Only documents that contain a vector of the size and in the field specified by a vector index will be included in the index and returned by the vector search.

For information on limits, see here.

We're always open to customer feedback and requests. Some ideas we've considered for improving vector search in Convex include:

If any of these features is important for your app, let us know on Discord!

**Examples:**

Example 1 (ts):
```ts
foods: defineTable({  description: v.string(),  cuisine: v.string(),  embedding: v.array(v.float64()),}).vectorIndex("by_embedding", {  vectorField: "embedding",  dimensions: 1536,  filterFields: ["cuisine"],}),
```

Example 2 (ts):
```ts
import { v } from "convex/values";import { action } from "./_generated/server";export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // ...  },});
```

Example 3 (ts):
```ts
export const fetchResults = internalQuery({  args: { ids: v.array(v.id("foods")) },  handler: async (ctx, args) => {    const results = [];    for (const id of args.ids) {      const doc = await ctx.db.get(id);      if (doc === null) {        continue;      }      results.push(doc);    }    return results;  },});
```

Example 4 (ts):
```ts
export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // 3. Fetch the results    const foods: Array<Doc<"foods">> = await ctx.runQuery(      internal.foods.fetchResults,      { ids: results.map((result) => result._id) },    );    return foods;  },});
```

---

## Actions

**URL:** https://docs.convex.dev/functions/actions

**Contents:**
- Actions
- Action names​
- The action constructor​
  - Action arguments and responses​
  - Action context​
  - Dealing with circular type inference​
- Choosing the runtime ("use node")​
- Splitting up action code via helpers​
- Calling actions from clients​
- Limits​

Actions can call third party services to do things such as processing a payment with Stripe. They can be run in Convex's JavaScript environment or in Node.js. They can interact with the database indirectly by calling queries and mutations.

Example: GIPHY Action

Actions follow the same naming rules as queries, see Query names.

To declare an action in Convex you use the action constructor function. Pass it an object with a handler function, which performs the action:

Unlike a query, an action can but does not have to return a value.

Action arguments and responses follow the same rules as mutations:

The first argument to the handler function is reserved for the action context.

The action constructor enables interacting with the database, and other Convex features by passing an ActionCtx object to the handler function as the first argument:

Which part of that action context is used depends on what your action needs to do:

To read data from the database use the runQuery field, and call a query that performs the read:

Here readData is an internal query because we don't want to expose it to the client directly. Actions, mutations and queries can be defined in the same file.

To write data to the database use the runMutation field, and call a mutation that performs the write:

Use an internal mutation when you want to prevent users from calling the mutation directly.

As with queries, it's often convenient to define actions and mutations in the same file.

To generate upload URLs for storing files use the storage field. Read on about File Storage.

To check user authentication use the auth field. Auth is propagated automatically when calling queries and mutations from the action. Read on about Authentication.

To schedule functions to run in the future, use the scheduler field. Read on about Scheduled Functions.

To search a vector index, use the vectorSearch field. Read on about Vector Search.

When the return value of an action depends on the result of calling ctx.runQuery or ctx.runMutation, TypeScript will complain that it cannot infer the return type of the action. This is a minimal example of the issue:

To work around this, there are two options:

TypeScript will check that the type annotation matches what the called query or mutation returns, so you don't lose any type safety.

In this trivial example the return type of the query was null. See the TypeScript page for other types which might be helpful when annotating the result.

Actions can run in Convex's custom JavaScript environment or in Node.js.

By default, actions run in Convex's environment. This environment supports fetch, so actions that simply want to call a third-party API using fetch can be run in this environment:

Actions running in Convex's environment are faster compared to Node.js, since they don't require extra time to start up before running your action (cold starts). They can also be defined in the same file as other Convex functions. Like queries and mutations they can import NPM packages, but not all are supported.

Actions needing unsupported NPM packages or Node.js APIs can be configured to run in Node.js by adding the "use node" directive at the top of the file. Note that other Convex functions cannot be defined in files with the "use node"; directive.

Learn more about the two Convex Runtimes.

Just like with queries and mutations you can define and call helper

But note that the ActionCtx only has the auth field in common with QueryCtx and MutationCtx.

To call an action from React use the useAction hook along with the generated api object.

Unlike mutations, actions from a single client are parallelized. Each action will be executed as soon as it reaches the server (even if other actions and mutations from the same client are running). If your app relies on actions running after other actions or mutations, make sure to only trigger the action after the relevant previous function completes.

Note: In most cases calling an action directly from a client is an anti-pattern. Instead, have the client call a mutation which captures the user intent by writing into the database and then schedules an action:

This way the mutation can enforce invariants, such as preventing the user from executing the same action twice.

Actions time out after 10 minutes. Node.js and Convex runtime have 512MB and 64MB memory limit respectively. Please contact us if you have a use case that requires configuring higher limits.

Actions can do up to 1000 concurrent operations, such as executing queries, mutations or performing fetch requests.

For information on other limits, see here.

Unlike queries and mutations, actions may have side-effects and therefore can't be automatically retried by Convex when errors occur. For example, say your action calls Stripe to send a customer invoice. If the HTTP request fails, Convex has no way of knowing if the invoice was already sent. Like in normal backend code, it is the responsibility of the caller to handle errors raised by actions and retry the action call if appropriate.

Make sure to await all promises created within an action. Async tasks still running when the function returns might or might not complete. In addition, since the Node.js execution environment might be reused between action calls, dangling promises might result in errors in subsequent action invocations.

Why? await ctx.runAction incurs to overhead of another Convex server function. It counts as an extra function call, it allocates its own system resources, and while you're awaiting this call the parent action call is frozen holding all it's resources. If you pile enough of these calls on top of each other, your app may slow down significantly.

Fix: The reason this api exists is to let you run code in the Node.js environment. If you want to call an action from another action that's in the same runtime, which is the normal case, the best way to do this is to pull the code you want to call into a TypeScript helper function and call the helper instead.

Why? Multiple runQuery / runMutations execute in separate transactions and aren’t guaranteed to be consistent with each other (e.g. foo and bar could read the same document and return two different results), while a single runQuery / runMutation will always be consistent. Additionally, you’re paying for multiple function calls when you don’t have to.

Fix: Make a new internal query / mutation that does both things. Refactoring the code for the two functions into helpers will make it easy to create a new internal function that does both things while still keeping around the original functions. Potentially try and refactor your action code to “batch” all the database access.

Caveats: Separate runQuery / runMutation calls are valid when intentionally trying to process more data than fits in a single transaction (e.g. running a migration, doing a live aggregate).

**Examples:**

Example 1 (ts):
```ts
import { action } from "./_generated/server";export const doSomething = action({  handler: () => {    // implementation goes here    // optionally return a value    return "success";  },});
```

Example 2 (ts):
```ts
import { action } from "./_generated/server";import { v } from "convex/values";export const doSomething = action({  args: { a: v.number(), b: v.number() },  handler: (_, args) => {    // do something with `args.a` and `args.b`    // optionally return a value    return "success";  },});
```

Example 3 (ts):
```ts
import { action } from "./_generated/server";import { v } from "convex/values";export const doSomething = action({  args: { a: v.number(), b: v.number() },  handler: (ctx, args) => {    // do something with `ctx`  },});
```

Example 4 (ts):
```ts
import { action, internalQuery } from "./_generated/server";import { internal } from "./_generated/api";import { v } from "convex/values";export const doSomething = action({  args: { a: v.number() },  handler: async (ctx, args) => {    const data = await ctx.runQuery(internal.myFunctions.readData, {      a: args.a,    });    // do something with `data`  },});export const readData = internalQuery({  args: { a: v.number() },  handler: async (ctx, args) => {    // read from `ctx.db` here  },});
```

---

## Convex Overview

**URL:** https://docs.convex.dev/understanding/

**Contents:**
- Convex Overview
- Database​
- Server functions​
- Client libraries​
- Putting it all together​
- Beyond reactivity​
- For human and AI generated code​
- Learn more​

Convex is the open source, reactive database where queries are TypeScript code running right in the database. Just like React components react to state changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client libraries. It makes it easy to build and scale dynamic live-updating apps.

The following diagram shows the standard three-tier app architecture that Convex enables. We'll start at the bottom and work our way up to the top of this diagram.

The database is at the core of Convex. The Convex database is automatically provisioned when you create your project. There is no connection setup or cluster management.

In Convex, your database queries are just TypeScript code written in your server functions. There is no SQL to write. There are no ORMs needed.

The Convex database is reactive. Whenever any data on which a query depends changes, the query is rerun, and client subscriptions are updated.

Convex is a "document-relational" database. "Document" means you put JSON-like nested objects into your database. "Relational" means you have tables with relations, like tasks assigned to a user using IDs to reference documents in other tables.

The Convex cloud offering runs on top of Amazon RDS using MySQL as its persistence layer. The Open Source version uses SQLite, Postgres and MySQL. The database is ACID-compliant and uses serializable isolation and optimistic concurrency control. All that to say, Convex provides the strictest possible transactional guarantees, and you never see inconsistent data.

When you create a new Convex project, you automatically get a convex/ folder where you write your server functions. This is where all your backend application logic and database query code live.

Example TypeScript server functions that read (query) and write (mutation) to the database.

You read and write to your database through query or mutation functions. Query functions are pure functions that can only read from the database. Mutation functions are transactions that can read or write from the database. These two database functions are not allowed to take any non-deterministic actions like network requests to ensure transactional guarantees.

The entire Convex mutation function is a transaction. There are no begin or end transaction statements to write. Convex automatically retries the function on conflicts, and you don't have to manage anything.

Convex also provides standard general-purpose serverless functions called actions. Action functions can make network requests. They have to call query or mutation functions to read and write to the database. You use actions to call LLMs or send emails.

You can also durably schedule Convex functions via the scheduler or cron jobs. Scheduling lets you build workflows like emailing a new user a day later if they haven't performed an onboarding task.

You call your Convex functions via client libraries or directly via HTTP.

Convex client libraries keep your frontend synced with the results of your server functions.

Like the useState hook that updates your React component when local state changes, the Convex useQuery hook automatically updates your component whenever the result of your query changes. There's no manual subscription management or state synchronization needed.

When calling query functions, the client library subscribes to the results of the function. Convex tracks the dependencies of your query functions, including what data was read from the database. Whenever relevant data in the database changes, the Convex automatically reruns the query and sends the result to the client.

The client library also queues up mutations in memory to send to the server. As mutations execute and cause query results to update, the client library keeps your app state consistent. It updates all subscriptions to the same logical moment in time in the database.

Convex provides client libraries for nearly all popular web and native app frameworks. Client libraries connect to your Convex deployment via WebSockets. You can then call your public Convex functions through the library. You can also use Convex with HTTP directly, you just won't get the automatic subscriptions.

Let's return to the getAllOpenTasks Convex query function from earlier that gets all tasks that are not marked as completed:

Let's follow along what happens when you subscribe to this query:

The web app uses the useQuery hook to subscribe to this query, and the following happens to get an initial value:

In this case the initial result looks like this (1):

Then you use a mutation to mark an item as completed (2). Convex then reruns the query (3) to get an updated result. And pushes the result to the web app via the WebSocket connection (4):

Beyond reactivity, Convex's architecture is crucial for a deeper reason. Convex does not let your app have inconsistent state at any layer of the stack.

To illustrate this, let's imagine you're building a shopping cart for an e-commerce store.

On the product listing page, you have two numbers, one showing the number of items remaining in stock and another showing the number of items in your shopping cart. Each number is a result of a different query function.

Every time you press the "Add to Cart" button, a mutation is called to remove one item from the stock and add it to the shopping cart.

The mutation to change the cart runs in a transaction, so your database is always in a consistent state. The reactive database knows that the queries showing the number of items in stock and the number of items in the shopping cart both need to be updated. The queries are invalidated and rerun. The results are pushed to the web app via the WebSocket connection.

The client library makes sure that both queries update at the same time in the web app since they reflect a singular moment in time in your database. You never have a moment where those numbers don't add up. Your app always shows consistent data.

You can see this example in action in the Swaghaus sample app.

Convex is designed around a small set of composable abstractions with strong guarantees that result in code that is not only faster to write, it’s easier to read and maintain, whether written by a team member or an LLM. Key features make sure you get bug-free AI generated code:

Together, these features mean AI can focus on your business logic while Convex's guarantees prevent common failure modes.

If you are intrigued about the details of how Convex pulls this all off, you can read Convex co-founder Sujay's excellent How Convex Works blog post.

Now that you have a good sense of how Convex fits in your app. Let's walk through the overall workflow of setting up and launching a Convex app.

**Examples:**

Example 1 (typescript):
```typescript
// A Convex query functionexport const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});// A Convex mutation functionexport const setTaskCompleted = mutation({  args: { taskId: v.id("tasks"), completed: v.boolean() },  handler: async (ctx, { taskId, completed }) => {    // Update the database using TypeScript    await ctx.db.patch(taskId, { completed });  },});
```

Example 2 (tsx):
```tsx
// In your React componentimport { useQuery } from "convex/react";import { api } from "../convex/_generated/api";export function TaskList() {  const data = useQuery(api.tasks.getAllOpenTasks);  return data ?? "Loading...";}
```

Example 3 (typescript):
```typescript
export const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});
```

Example 4 (json):
```json
[  { _id: "e4g", title: "Grocery shopping", complete: false },  { _id: "u9v", title: "Plant new flowers", complete: false },];
```

---

## Using Components

**URL:** https://docs.convex.dev/components/using-components

**Contents:**
- Using Components
- Installing Components​
- Component functions​
- Transactions​
- Dashboard​

Convex components add new features to your backend in their own sandbox with their own functions, schema and data, scheduled functions and all other fundamental Convex features.

You can see the full list of components in the directory. Each component README provides full instructions on how to install and use them.

This doc will go through common patterns on how to install and use Components.

We'll use the Sharded Counter component as an example.

Install the relevant package from npm

Create or update the convex.config.ts file in your app's convex/ folder and install the component by calling use:

Make sure the convex dev cli is running to ensure the component is registered with your backend and the necessary code is generated.

Each component has its own API. Check out each component's README file for more details on its usage.

Though components may expose higher level TypeScript APIs, under the hood they are called via normal Convex functions over the component sandbox boundary.

Queries, mutations, and action rules still apply - queries can only call component queries, mutations can also call component mutations, and actions can also call component actions. As a result, queries into components are reactive by default, and mutations have the same transaction guarantees.

Remember that mutation functions in Convex are transactions. Either all the changes in the mutation get written at once or none are written at all.

All writes for a top-level mutation call, including writes performed by calls into other components' mutations, are committed at the same time. If the top-level mutation throws an error, all of the writes are rolled back, and the mutation doesn't change the database at all.

However, if a component mutation call throws an exception, only its writes are rolled back. Then, if the caller catches the exception, it can continue, perform more writes, and return successfully. If the caller doesn't catch the exception, then it's treated as failed and all the writes associated with the caller mutation are rolled back. This means your code can choose a different code path depending on the semantics of your component.

As an example, take the Rate Limiter component. One API of the Rate Limiter throws an error if a rate limit is hit:

If the call to rateLimiter.limit throws an exception, we're over the rate limit. Then, if the calling mutation doesn't catch this exception, the whole transaction is rolled back.

The calling mutation, on the other hand, could also decide to ignore the rate limit by catching the exception and proceeding. For example, an app may want to ignore rate limits if there is a development environment override. In this case, only the component mutation will be rolled back, and the rest of the mutation will continue.

You can see your component’s data, functions, files, and other info using the dropdown in the Dashboard.

**Examples:**

Example 1 (bash):
```bash
npm i @convex-dev/sharded-counter
```

Example 2 (ts):
```ts
// convex/convex.config.tsimport { defineApp } from "convex/server";import shardedCounter from "@convex-dev/sharded-counter/convex.config";const app = defineApp();app.use(shardedCounter);//... Add other components hereexport default app;
```

Example 3 (bash):
```bash
npx convex dev
```

Example 4 (ts):
```ts
// Automatically throw an error if the rate limit is hit.await rateLimiter.limit(ctx, "failedLogins", { key: userId, throws: true });
```

---

## Local Deployments for Development

**URL:** https://docs.convex.dev/cli/local-deployments

**Contents:**
- Local Deployments for Development
- Background on deployments in Convex​
- Using local deployments​
  - Anonymous development​
  - Local deployments for an existing project​
- Local deployments vs. production​
  - Disabling​
- Limitations​

Instead of syncing code to a Convex dev deployment hosted in the cloud, you can develop against a deployment running on your own computer. You can even use the Convex dashboard with local deployments!

Each Convex deployment contains its own data, functions, scheduled functions, etc. A project has one production deployment, up to one cloud deployment for development per team member, and potentially many transient preview deployments.

You can also develop with Convex using a deployment running on your own machine. Since the deployment is running locally, code sync is faster and means resources like functions calls and database bandwidth don't count against the quotas for your Convex plan.

You can use local deployments with an existing Convex project, and view your deployment in the Convex dashboard under your project. You can also use local deployments without a Convex account and debug and inspect them with a locally running version of the Convex dashboard.

Local deployments are currently a beta feature. If you have feedback or feature requests, let us know on Discord!

While using local deployments, the local Convex backend runs as a subprocess of the npx convex dev command and exits when that command is stopped. This means a convex dev command must be running in order to run other commands like npx convex run against this local deployment or for your frontend to connect to this deployment.

State for local backends is stored the ~/.convex/ directory.

You can use local deployments to develop with Convex without having to create an account. Whenever you want to create an account to deploy your app to production or to use more Convex features, you can use npx convex login to link your local deployments with your account.

To use a local deployment for an existing project, run:

You'll also always be given the option for a local deployment if you run npx convex dev --configure. Other flows may assume you want a cloud deployment in some situations, for example when connecting to a project for which you already have a cloud development deployment.

Local deployments are not recommended for production use: they're development deployments, i.e. logs for function results and full stack traces for error responses are sent to connected clients.

For running a production application, you can use a production deployment hosted on the Convex cloud. Learn more about deploying to production here.

Alternatively, you can self-host a production deployment using the open source convex-backend repo.

To stop using local developments for a project, run the following:

Remember your cloud dev deployment and each local dev deployment are completely separate, so contain different data. When switching between deployments you may wish to export and re-import the data to keep using it.

No Public URL - Cloud deployments have public URL to receive incoming HTTP requests from services like Twilio, but local deployments listen for HTTP requests on your own computer. Similarly, you can't power websites with Convex WebSocket connections unless your users browsers know how to reach your computer. Set up a proxy like ngrok or use a cloud deployment for these uses cases.

Node actions require specific Node.js versions - Running Node.js actions (actions defined in files with "use node;") requires having Node.js 18 installed, since this is the version of Node.js used in production when Node.js actions run in AWS Lambda functions. To resolve this you can install and set up nvm and then install Node.js version 18. You don't need to use Node.js 18 for the rest of your project.

Node.js actions run directly on your computer - Like a normal Node.js server, code running in Node.js actions has unrestricted filesystem access. Queries, mutations, and Convex runtime actions still run in isolated environments.

Logs get cleared out every time a npx convex dev command is restarted.

Using the dashboard with Safari: Safari blocks requests to localhost, which prevents the dashboard from working with local deployments. We recommend using another browser if you’re using local deployments.

Using the dashboard with Brave: Brave blocks requests to localhost by default, which prevents the dashboard from working with local deployments. You can use the following workaround:

**Examples:**

Example 1 (sh):
```sh
npx convex dev --local --once
```

Example 2 (sh):
```sh
npx convex disable-local-deployments
```

---

## Errors and Warnings

**URL:** https://docs.convex.dev/error

**Contents:**
- Errors and Warnings
- Write conflict: Optimistic concurrency control​
  - Example A​
  - Example B​
  - Remediation​
  - Resources​

This page explains specific errors thrown by Convex.

See Error Handling to learn about handling errors in general.

This system error is thrown when a mutation repeatedly fails due to conflicting changes from parallel mutation executions.

A mutation updateCounter always updates the same document:

If this mutation is called many times per second, many of its executions will conflict with each other. Convex internally does several retries to mitigate this concern, but if the mutation is called more rapidly than Convex can execute it, some of the invocations will eventually throw this error:

Documents read from or written to the table "counters" changed while this mutation was being run and on every subsequent retry. Another call to this mutation changed the document with ID "123456789101112".

The error message will note the table name, which mutation caused the conflict (in this example its another call to the same mutation), and one document ID which was part of the conflicting change.

Mutation writeCount depends on the entire tasks table:

If the mutation writeCount is called at the same time as many calls to addTask are made, either of the mutations can fail with this error. This is because any change to the "tasks" table will conflict with the writeCount mutation:

Documents read from or written to the table "tasks" changed while this mutation was being run and on every subsequent retry. A call to "addTask" changed the document with ID "123456789101112".

**Examples:**

Example 1 (ts):
```ts
export const updateCounter = mutation({  args: {},  handler: async (ctx) => {    const doc = await ctx.db.get(process.env.COUNTER_ID);    await ctx.db.patch(doc._id, { value: doc.value + 1 });  },});
```

Example 2 (ts):
```ts
export const writeCount = mutation({  args: {    target: v.id("counts"),  },  handler: async (ctx, args) => {    const tasks = await ctx.db.query("tasks").collect();    await ctx.db.patch(args.target, { value: tasks });  },});export const addTask = mutation({  args: {    text: v.string(),  },  handler: async (ctx, args) => {    await ctx.db.insert("tasks", { text: args.text });  },});
```

---

## File Storage

**URL:** https://docs.convex.dev/file-storage

**Contents:**
- File Storage

File Storage makes it easy to implement file upload in your app, store files from and send files to third-party APIs, and to serve dynamic files to your users. All file types are supported.

You can manage your stored files on the dashboard.

Examples: File Storage with HTTP Actions, File Storage with Queries and Mutations

---

## CLI

**URL:** https://docs.convex.dev/using/cli

**Contents:**
- CLI
- Configure​
  - Create a new project​
  - Recreate project configuration​
  - Log out​
- Develop​
  - Run the Convex dev server​
  - Open the dashboard​
  - Open the docs​
  - Run Convex functions​

The Convex command-line interface (CLI) is your interface for managing Convex projects and Convex functions.

To install the CLI, run:

You can view the full list of commands with:

The first time you run

it will ask you to log in your device and create a new Convex project. It will then create:

in a project directory without a set CONVEX_DEPLOYMENT to configure a new or existing project.

Remove the existing Convex credentials from your device, so subsequent commands like npx convex dev can use a different Convex account.

Watches the local filesystem. When you change a function or the schema, the new versions are pushed to your dev deployment and the generated types in convex/_generated are updated. By default, logs from your dev deployment are displayed in the terminal.

It's also possible to run a Convex deployment locally for development.

Open the Convex dashboard.

Get back to these docs!

Run a public or internal Convex query, mutation, or action on your development deployment.

Arguments are specified as a JSON object.

Add --watch to live update the results of a query. Add --push to push local code to the deployment before running the function.

Use --prod to run functions in the production deployment for a project.

You can choose how to pipe logs from your dev deployment to your console:

Use --prod with npx convex logs to tail the prod deployment logs instead.

See description and use-cases: data import.

See description and use-cases: data export.

Display a simple view of the dashboard data page in the command line.

The command supports --limit and --order flags to change data displayed. For more complex filters, use the dashboard data page or write a query.

The npx convex data <table> command works with system tables, such as _storage, in addition to your own tables.

See and update the deployment environment variables which you can otherwise manage on the dashboard environment variables settings page.

The target deployment to push to is determined like this:

Once this command succeeds the new functions will be available immediately.

When run with the CONVEX_DEPLOY_KEY environment variable containing a Preview Deploy Key, this command will:

Create a new Convex deployment. npx convex deploy will infer the Git branch name for Vercel, Netlify, GitHub, and GitLab environments, or the --preview-create option can be used to customize the name associated with the newly created deployment.

Run a command if specified with --cmd. The command will have CONVEX_URL (or similar) environment variable available:

You can customize the URL environment variable name with --cmd-url-env-var-name:

Typecheck your Convex functions.

Regenerate the generated code in the convex/_generated directory.

Bundle your Convex functions and their dependencies.

Push your functions, indexes, and schema to the deployment.

Run a function specified by --preview-run (similar to the --run option for npx convex dev).

See the Vercel or Netlify hosting guide for setting up frontend and backend previews together.

The generated code in the convex/_generated directory includes types required for a TypeScript typecheck. This code is generated whenever necessary while running npx convex dev and this code should be committed to the repo (your code won't typecheck without it!).

In the rare cases it's useful to regenerate code (e.g. in CI to ensure that the correct code was checked it) you can use this command.

Generating code can require communicating with a convex deployment in order to evaluate configuration files in the Convex JavaScript runtime. This doesn't modify the code running on the deployment.

**Examples:**

Example 1 (sh):
```sh
npm install convex
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (sh):
```sh
npx convex dev
```

Example 4 (sh):
```sh
npx convex logout
```

---

## Continuous Integration

**URL:** https://docs.convex.dev/testing/ci

**Contents:**
- Continuous Integration
- Testing in GitHub Actions​

Continuous integration allows your team to move fast by combining changes from all team members and automatically testing them on a remote machine.

It's easy if you're using GitHub to set up CI workflow for running your test suite:

After you commit and push this file to your repository, GitHub will run npm run test every time you create a pull request or push a new commit.

**Examples:**

Example 1 (yaml):
```yaml
name: Run Testson: [pull_request, push]jobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4      - uses: actions/setup-node@v4      - run: npm ci      - run: npm run test
```

---

## Cron Jobs

**URL:** https://docs.convex.dev/scheduling/cron-jobs

**Contents:**
- Cron Jobs
- Defining your cron jobs​
- Supported schedules​
- Viewing your cron jobs​
- Error handling​

Convex allows you to schedule functions to run on a recurring basis. For example, cron jobs can be used to clean up data at a regular interval, send a reminder email at the same time every month, or schedule a backup every Saturday.

Cron jobs are defined in a crons.ts file in your convex/ directory and look like:

The first argument is a unique identifier for the cron job.

The second argument is the schedule at which the function should run, see Supported schedules below.

The third argument is the name of the public function or internal function, either a mutation or an action.

You can view all your cron jobs in the Convex dashboard cron jobs view. You can view added, updated, and deleted cron jobs in the logs and history view. Results of previously executed runs of the cron jobs are also available in the logs view.

Mutations and actions have the same guarantees that are described in Error handling for scheduled functions.

At most one run of each cron job can be executing at any moment. If the function scheduled by the cron job takes too long to run, following runs of the cron job may be skipped to avoid execution from falling behind. Skipping a scheduled run of a cron job due to the previous run still executing logs a message visible in the logs view of the dashboard.

**Examples:**

Example 1 (ts):
```ts
import { cronJobs } from "convex/server";import { internal } from "./_generated/api";const crons = cronJobs();crons.interval(  "clear messages table",  { minutes: 1 }, // every minute  internal.messages.clearAll,);crons.monthly(  "payment reminder",  { day: 1, hourUTC: 16, minuteUTC: 0 }, // Every month on the first day at 8:00am PST  internal.payments.sendPaymentEmail,  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail);// An alternative way to create the same schedule as above with cron syntaxcrons.cron(  "payment reminder duplicate",  "0 16 1 * *",  internal.payments.sendPaymentEmail,  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail);export default crons;
```

---

## 

**URL:** https://docs.convex.dev

---

## Custom JWT Provider

**URL:** https://docs.convex.dev/auth/advanced/custom-jwt

**Contents:**
- Custom JWT Provider
- Server-side integration​
  - Warning: omitting applicationID is often insecure​
  - Custom claims​
- Client-side integration​

Note: This is an advanced feature! We recommend sticking with the supported third-party authentication providers.

A JWT is a string combining three base64-encoded JSON objects containing claims about who a user is valid for a limited period of time like an hour. You can create them with a library like jose after receiving some evidence (typically a cookie) of a user's identity or get them from a third party authentication service like Clerk. The information in a JWT is signed (the Convex deployment can tell the information is really from the issuer and hasn't been modified) but generally not encrypted (you can read it by base64-decoding the token or pasting it into jwt.io.

If the JWTs issued to your users by an authentication service contain the right fields to implement the OpenID Connect (OIDC) protocol, the easiest way to configure accepting these JWTs is adding an OIDC Provider entry in convex/auth.config.ts. If the authentication service or library you're using to issue JWTs doesn't support these fields (for example OpenAuth JWTs missing an aud field because they implement the OAuth 2.0 spec but not OIDC) you'll need to configure a Custom JWT provider in the convex/auth.config.ts file.

Custom JWTs are required only to have header fields kid, alg and typ, and payload fields sub, iss, and exp. An iat field is also expected by Convex clients to implement token refreshing.

Use type: "customJwt" to configure a Custom JWT auth provider:

The issuer property must exactly match the iss field of the JWT used and if specified the applicationID property must exactly match the aud field. If your JWT doesn't match, use a tool like jwt.io to view an JWT and confirm these fields match exactly.

Leaving out applicationID from an auth configuration means the aud (audience) field of your users' JWTs will not be verified. In many cases this is insecure because a JWT intended for another service can be used to impersonate them in your service.

Say a user has accounts with https://todos.com and https://banking.com, two services which use the same third-party authentication service, accounts.google.com. A JWT accepted by todos.com could be reused to authenticate with banking.com by either todos.com or an attacker that obtained access to that JWT.

The aud (audience) field of the JWT prevents this: if the JWT was generated for a specific audience of https://todos.com then banking.com can enforce the aud field and know not to accept it.

If the JWTs issued to your users have an iss (issuer) URL like https://accounts.google.com that is not specific to your application, it is not secure to trust these tokens without an ApplicationID because that JWT could have been collected by a malicious application.

If the JWTs issued to your users have a more specific iss field like https://api.3rd-party-auth.com/client_0123... then it may be secure to use no aud field if you control all the services the issuer url grants then access to and intend for access to any one of these services to grants access to all of them.

In addition to top-level fields like subject, issuer, and tokenIdentifier, subfields of the nested fields of the JWT will be accessible in the auth data returned from const authInfo = await ctx.auth.getUserIdentity() like authInfo["properties.id"] and authInfo["properties.favoriteColor"] for a JWT structured like this:

Your users' browsers need a way to obtain an initial JWT and to request updated JWTs, ideally before the previous one expires.

See the instructions for Custom OIDC Providers for how to do this.

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      type: "customJwt",      applicationID: "your-application-id",      issuer: "https://your.issuer.url.com",      jwks: "https://your.issuer.url.com/.well-known/jwks.json",      algorithm: "RS256",    },  ],};
```

Example 2 (json):
```json
{  "properties": {    "id": "123",    "favoriteColor": "red"  },  "iss": "http://localhost:3000",  "sub": "user:8fa2be73c2229e85",  "exp": 1750968478}
```

---

## Functions

**URL:** https://docs.convex.dev/functions

**Contents:**
- Functions

Functions run on the backend and are written in JavaScript (or TypeScript). They are automatically available as APIs accessed through client libraries. Everything you do in the Convex backend starts from functions.

There are three types of functions:

You can also build HTTP actions when you want to call your functions from a webhook or a custom client.

Here's an overview of the three different types of Convex functions and what they can do:

---

## Queries

**URL:** https://docs.convex.dev/functions/query-functions

**Contents:**
- Queries
- Query names​
- The query constructor​
  - Query arguments​
  - Query responses​
  - Query context​
- Splitting up query code via helpers​
- Using NPM packages​
- Calling queries from clients​
- Caching & reactivity & consistency​

Queries are the bread and butter of your backend API. They fetch data from the database, check authentication or perform other business logic, and return data back to the client application.

This is an example query, taking in named arguments, reading data from the database and returning a result:

Read on to understand how to build queries yourself.

Queries are defined in

The path and name of the file, as well as the way the function is exported from the file, determine the name the client will use to call it:

To structure your API you can nest directories inside the convex/ directory:

Default exports receive the name default.

The same rules apply to mutations and actions, while HTTP actions use a different routing approach.

Client libraries in languages other than JavaScript and TypeScript use strings instead of API objects:

To actually declare a query in Convex you use the query constructor function. Pass it an object with a handler function, which returns the query result:

Queries accept named arguments. The argument values are accessible as fields of the second parameter of the handler function:

Arguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your query.

To both declare the types of arguments and to validate them, add an args object using v validators:

See argument validation for the full list of supported types and validators.

The first parameter of the handler function contains the query context.

Queries can return values of any supported Convex type which will be automatically serialized and deserialized.

Queries can also return undefined, which is not a valid Convex value. When a query returns undefined it is translated to null on the client.

The query constructor enables fetching data, and other Convex features by passing a QueryCtx object to the handler function as the first parameter:

Which part of the query context is used depends on what your query needs to do:

To fetch from the database use the db field. Note that we make the handler function an async function so we can await the promise returned by db.get():

Read more about Reading Data.

To return URLs to stored files use the storage field. Read more about File Storage.

To check user authentication use the auth field. Read more about Authentication.

When you want to split up the code in your query or reuse logic across multiple Convex functions you can define and call helper

You can export helpers to use them across multiple files. They will not be callable from outside of your Convex functions.

See Type annotating server side helpers for more guidance on TypeScript types.

Queries can import NPM packages installed in node_modules. Not all NPM packages are supported, see Runtimes for more details.

To call a query from React use the useQuery hook along with the generated api object.

See the React client documentation for all the ways queries can be called.

Queries have three awesome attributes:

To have these attributes the handler function must be deterministic, which means that given the same arguments (including the query context) it will return the same response.

For this reason queries cannot fetch from third party APIs. To call third party APIs, use actions.

You might wonder whether you can use non-deterministic language functionality like Math.random() or Date.now(). The short answer is that Convex takes care of implementing these in a way that you don't have to think about the deterministic constraint.

See Runtimes for more details on the Convex runtime.

Queries have a limit to the amount of data they can read at once to guarantee good performance. Check out these limits in Read/write limit errors.

For information on other limits, see Limits.

**Examples:**

Example 1 (ts):
```ts
import { query } from "./_generated/server";import { v } from "convex/values";// Return the last 100 tasks in a given task list.export const getTaskList = query({  args: { taskListId: v.id("taskLists") },  handler: async (ctx, args) => {    const tasks = await ctx.db      .query("tasks")      .filter((q) => q.eq(q.field("taskListId"), args.taskListId))      .order("desc")      .take(100);    return tasks;  },});
```

Example 2 (ts):
```ts
// This function will be referred to as `api.myFunctions.myQuery`.export const myQuery = …;// This function will be referred to as `api.myFunctions.sum`.export const sum = …;
```

Example 3 (ts):
```ts
// This function will be referred to as `api.foo.myQueries.listMessages`.export const listMessages = …;
```

Example 4 (ts):
```ts
// This function will be referred to as `api.myFunctions.default`.export default …;
```

---

## Serving Files

**URL:** https://docs.convex.dev/file-storage/serve-files

**Contents:**
- Serving Files
- Generating file URLs in queries​
- Serving files from HTTP actions​

Files stored in Convex can be served to your users by generating a URL pointing to a given file.

The simplest way to serve files is to return URLs along with other data required by your app from queries and mutations.

A file URL can be generated from a storage ID by the storage.getUrl function of the QueryCtx, MutationCtx, or ActionCtx object:

File URLs can be used in img elements to render images:

In your query you can control who gets access to a file when the URL is generated. If you need to control access when the file is served, you can define your own file serving HTTP actions instead.

You can serve files directly from HTTP actions. An HTTP action will need to take some parameter(s) that can be mapped to a storage ID, or a storage ID itself.

This enables access control at the time the file is served, such as when an image is displayed on a website. But note that the HTTP actions response size is currently limited to 20MB. For larger files you need to use file URLs as described above.

A file Blob object can be generated from a storage ID by the storage.get function of the ActionCtx object, which can be returned in a Response:

The URL of such an action can be used directly in img elements to render images:

**Examples:**

Example 1 (ts):
```ts
import { query } from "./_generated/server";export const list = query({  args: {},  handler: async (ctx) => {    const messages = await ctx.db.query("messages").collect();    return Promise.all(      messages.map(async (message) => ({        ...message,        // If the message is an "image" its `body` is an `Id<"_storage">`        ...(message.format === "image"          ? { url: await ctx.storage.getUrl(message.body) }          : {}),      })),    );  },});
```

Example 2 (tsx):
```tsx
function Image({ message }: { message: { url: string } }) {  return <img src={message.url} height="300px" width="auto" />;}
```

Example 3 (ts):
```ts
import { httpRouter } from "convex/server";import { httpAction } from "./_generated/server";import { Id } from "./_generated/dataModel";const http = httpRouter();http.route({  path: "/getImage",  method: "GET",  handler: httpAction(async (ctx, request) => {    const { searchParams } = new URL(request.url);    const storageId = searchParams.get("storageId")! as Id<"_storage">;    const blob = await ctx.storage.get(storageId);    if (blob === null) {      return new Response("Image not found", {        status: 404,      });    }    return new Response(blob);  }),});export default http;
```

Example 4 (tsx):
```tsx
const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;function Image({ storageId }: { storageId: string }) {  // e.g. https://happy-animal-123.convex.site/getImage?storageId=456  const getImageUrl = new URL(`${convexSiteUrl}/getImage`);  getImageUrl.searchParams.set("storageId", storageId);  return <img src={getImageUrl.href} height="300px" width="auto" />;}
```

---

## Authentication

**URL:** https://docs.convex.dev/auth

**Contents:**
- Authentication
- Third-party authentication platforms​
- The Convex Auth Library​
- Debugging​
- Service Authentication​
- Authorization​

Convex deployment endpoints are exposed to the open internet and the claims clients make about who they are must be authenticated to identify users and restrict what data they can see and edit.

Convex is compatible with most authentication providers because it uses OpenID Connect (based on OAuth) ID tokens in the form of JWTs to authenticate WebSocket connections or RPCs. These JWTs can be provided by any service (including your own Convex backend) that implement the appropriate OAuth endpoints to verify them.

Leveraging a Convex integration with a third-party auth provider provides the most comprehensive authentication solutions. Integrating another service provides a ton of functionality like passkeys, two-factor auth, spam protection, and more on top of the authentication basics.

After you integrate one of these, learn more about accessing authentication information in Functions and storing user information in the Database.

For client-side React and React Native mobile apps you can implement auth directly in Convex with the Convex Auth library. This npm package runs on your Convex deployment and helps you build a custom sign-up/sign-in flow via social identity providers, one-time email or SMS access codes, or via passwords.

Convex Auth is in beta (it isn't complete and may change in backward-incompatible ways) and doesn't provide as many features as third party auth integrations. Since it doesn't require signing up for another service it's the quickest way to get auth up and running.

Convex Auth is currently a beta feature. If you have feedback or feature requests, let us know on Discord!

Support for Next.js is under active development. If you'd like to help test this experimental support please give it a try!

If you run into issues consult the Debugging guide.

Servers you control or third party services can call Convex functions but may not be able to obtain OpenID JWTs and often do not represent the actions of a specific user.

Say you're running some inference on a Modal server written in Python. When that server subscribes to a Convex query it doesn't do so with credentials of a particular end-user, rather it's looking for relevant tasks for any users that need that inference task, say summarizing and translating a conversation, completed.

To provide access to Convex queries, mutations, and actions to an external service you can write public functions accessible to the internet that check a shared secret, for example from an environment variable, before doing anything else.

Convex enables a traditional three tier application structure: a client/UI for your app, a backend that handles user requests, and a database for queries. This architecture lets you check every public request against any authorization rules you can define in code.

This means Convex doesn't need an opinionated authorization framework like RLS, which is required in client oriented databases like Firebase or Supabase. This flexibility lets you build and use an authorization framework for your needs.

That said, the most common way is to simply write code that checks if the user is logged in and if they are allowed to do the requested action at the beginning of each public function.

For example, the following function enforces that only the currently authenticated user can remove their own user image:

**Examples:**

Example 1 (typescript):
```typescript
export const removeUserImage = mutation({  args: {},  handler: async (ctx) => {    const userId = await getAuthUserId(ctx);    if (!userId) {      return;    }    ctx.db.patch(userId, { imageId: undefined, image: undefined });  },});
```

---

## Best Practices

**URL:** https://docs.convex.dev/understanding/best-practices/

**Contents:**
- Best Practices
- Await all Promises​
  - Why?​
  - How?​
- Avoid .filter on database queries​
  - Why?​
  - Examples​
  - How?​
  - Exceptions​
- Only use .collect with a small number of results​

This is a list of best practices and common anti-patterns around using Convex. We recommend going through this list before broadly releasing your app to production. You may choose to try using all of these best practices from the start, or you may wait until you've gotten major parts of your app working before going through and adopting the best practices here.

Convex functions use async / await. If you don't await all your promises (e.g. await ctx.scheduler.runAfter, await ctx.db.patch), you may run into unexpected behavior (e.g. failing to schedule a function) or miss handling errors.

We recommend the no-floating-promises eslint rule with TypeScript.

Filtering in code instead of using the .filter syntax has the same performance, and is generally easier code to write. Conditions in .withIndex or .withSearchIndex are more efficient than .filter or filtering in code, so almost all uses of .filter should either be replaced with a .withIndex or .withSearchIndex condition, or written as TypeScript code.

Read through the indexes documentation for an overview of how to define indexes and how they work.

Search for .filter in your Convex codebase — a regex like \.filter\(\(?q will probably find all the ones on database queries.

Decide whether they should be replaced with a .withIndex condition — per this section, if you are filtering over a large (1000+) or potentially unbounded number of documents, you should use an index. If not using a .withIndex / .withSearchIndex condition, consider replacing them with a filter in code for more readability and flexibility.

See this article for more strategies for filtering.

Using .filter on a paginated query (.paginate) has advantages over filtering in code. The paginated query will return the number of documents requested, including the .filter condition, so filtering in code afterwards can result in a smaller page or even an empty page. Using .withIndex on a paginated query will still be more efficient than a .filter.

All results returned from .collect count towards database bandwidth (even ones filtered out by .filter). It also means that if any document in the result changes, the query will re-run or the mutation will hit a conflict.

If there's a chance the number of results is large (say 1000+ documents), you should use an index to filter the results further before calling .collect, or find some other way to avoid loading all the documents such as using pagination, denormalizing data, or changing the product feature.

Using a limit or denormalizing:

Search for .collect in your Convex codebase (a regex like \.collect\( will probably find these). And think through whether the number of results is small. This function health page in the dashboard can also help surface these.

The aggregate component or database triggers can be helpful patterns for denormalizing data.

If you're doing something that requires loading a large number of documents (e.g. performing a migration, making a summary), you may want to use an action to load them in batches via separate queries / mutations.

Indexes like by_foo and by_foo_and_bar are usually redundant (you only need by_foo_and_bar). Reducing the number of indexes saves on database storage and reduces the overhead of writing to the table.

Look through your indexes, either in your schema.ts file or in the dashboard, and look for any indexes where one is a prefix of another.

.index("by_foo", ["foo"]) is really an index on the properties foo and _creationTime, while .index("by_foo_and_bar", ["foo", "bar"]) is an index on the properties foo, bar, and _creationTime. If you have queries that need to be sorted by foo and then _creationTime, then you need both indexes.

For example, .index("by_channel", ["channel"]) on a table of messages can be used to query for the most recent messages in a channel, but .index("by_channel_and_author", ["channel", "author"]) could not be used for this since it would first sort the messages by author.

Public functions can be called by anyone, including potentially malicious attackers trying to break your app. Argument validators (as well as return value validators) help ensure you're getting the traffic you expect.

Search for query, mutation, and action in your Convex codebase, and ensure that all of them have argument validators (and optionally return value validators). If you have httpActions, you may want to use something like zod to validate that the HTTP request is the shape you expect.

Public functions can be called by anyone, including potentially malicious attackers trying to break your app. If portions of your app should only be accessible when the user is signed in, make sure all these Convex functions check that ctx.auth.getUserIdentity() is set.

You may also have specific checks, like only loading messages that were sent to or from the current user, which you'll want to apply in every relevant public function.

Favoring more granular functions like setTeamOwner over updateTeam allows more granular checks for which users can do what.

Access control checks should either use ctx.auth.getUserIdentity() or a function argument that is unguessable (e.g. a UUID, or a Convex ID, provided that this ID is never exposed to any client but the one user). In particular, don't use a function argument which could be spoofed (e.g. email) for access control checks.

Search for query, mutation, action, and httpAction in your Convex codebase, and ensure that all of them have some form of access control. Custom functions like authenticatedQuery can be helpful.

Some apps use Row Level Security (RLS) to check access to each document automatically whenever it's loaded, as described in this article. Alternatively, you can check access in each Convex function instead of checking access for each document.

Helper functions for common checks and common operations can also be useful -- e.g. isTeamMember, isTeamAdmin, loadTeam (which throws if the current user does not have access to the team).

Public functions can be called by anyone, including potentially malicious attackers trying to break your app, and should be carefully audited to ensure they can't be used maliciously. Functions that are only called within Convex can be marked as internal, and relax these checks since Convex will ensure that internal functions can only be called within Convex.

Search for ctx.runQuery, ctx.runMutation, and ctx.runAction in your Convex codebase. Also search for ctx.scheduler and check the crons.ts file. Ensure all of these use internal.foo.bar functions instead of api.foo.bar functions.

If you have code you want to share between a public Convex function and an internal Convex function, create a helper function that can be called from both. The public function will likely have additional access control checks.

Alternatively, make sure that api from _generated/api.ts is never used in your Convex functions directory.

Most logic should be written as plain TypeScript functions, with the query, mutation, and action wrapper functions being a thin wrapper around one or more helper function.

Concretely, most of your code should live in a directory like convex/model, and your public API, which is defined with query, mutation, and action, should have very short functions that mostly just call into convex/model.

Organizing your code this way makes several of the refactors mentioned in this list easier to do.

See the TypeScript page for useful types.

❌ This example overuses ctx.runQuery and ctx.runMutation, which is discussed more in the Avoid sequential ctx.runMutation / ctx.runQuery from actions section.

✅ Most of the code here is now in the convex/model directory. The API for this application is in convex/conversations.ts, which contains very little code itself.

Calling runAction has more overhead than calling a plain TypeScript function. It counts as an extra function call with its own memory and CPU usage, while the parent action is doing nothing except waiting for the result. Therefore, runAction should almost always be replaced with calling a plain TypeScript function. However, if you want to call code that requires Node.js from a function in the Convex runtime (e.g. using a library that requires Node.js), then you can use runAction to call the Node.js code.

Search for runAction in your Convex codebase, and see if the function it calls uses the same runtime as the parent function. If so, replace the runAction with a plain TypeScript function. You may want to structure your functions so the Node.js functions are in a separate directory so it's easier to spot these.

Each ctx.runMutation or ctx.runQuery runs in its own transaction, which means if they're called separately, they may not be consistent with each other. If instead we call a single ctx.runQuery or ctx.runMutation, we're guaranteed that the results we get are consistent.

Audit your calls to ctx.runQuery and ctx.runMutation in actions. If you see multiple in a row with no other code between them, replace them with a single ctx.runQuery or ctx.runMutation that handles both things. Refactoring your code to use helper functions will make this easier.

If you're intentionally trying to process more data than fits in a single transaction, like running a migration or aggregating data, then it makes sense to have multiple sequential ctx.runMutation / ctx.runQuery calls.

Multiple ctx.runQuery / ctx.runMutation calls are often necessary because the action does a side effect in between them. For example, reading some data, feeding it to an external service, and then writing the result back to the database.

While these queries and mutations run in the same transaction, and will give consistent results, they have extra overhead compared to plain TypeScript functions. Wanting a TypeScript helper function is much more common than needing ctx.runQuery or ctx.runMutation.

Audit your calls to ctx.runQuery and ctx.runMutation in queries and mutations. Unless one of the exceptions below applies, replace them with a plain TypeScript function.

**Examples:**

Example 1 (ts):
```ts
// ❌const tomsMessages = ctx.db  .query("messages")  .filter((q) => q.eq(q.field("author"), "Tom"))  .collect();// ✅// Option 1: Use an indexconst tomsMessages = await ctx.db  .query("messages")  .withIndex("by_author", (q) => q.eq("author", "Tom"))  .collect();// Option 2: Filter in codeconst allMessages = await ctx.db.query("messages").collect();const tomsMessages = allMessages.filter((m) => m.author === "Tom");
```

Example 2 (ts):
```ts
// ❌ -- potentially unboundedconst allMovies = await ctx.db.query("movies").collect();const moviesByDirector = allMovies.filter(  (m) => m.director === "Steven Spielberg",);// ✅ -- small number of results, so `collect` is fineconst moviesByDirector = await ctx.db  .query("movies")  .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))  .collect();
```

Example 3 (ts):
```ts
// ❌ -- potentially unboundedconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .collect();// ✅ -- using pagination, showing recently watched movies firstconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .order("desc")  .paginate(paginationOptions);
```

Example 4 (ts):
```ts
// ❌ -- potentially unboundedconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .collect();const numberOfWatchedMovies = watchedMovies.length;// ✅ -- Show "99+" instead of needing to load all documentsconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .take(100);const numberOfWatchedMovies =  watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();// ✅ -- Denormalize the number of watched movies in a separate tableconst watchedMoviesCount = await ctx.db  .query("watchedMoviesCount")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .unique();
```

---

## convex-test

**URL:** https://docs.convex.dev/testing/convex-test

**Contents:**
- convex-test
- Get Started​
- convexTest​
- Calling functions with t.query, t.mutation and t.action​
- Setting up and inspecting data and storage with t.run​
- Testing HTTP actions with t.fetch​
- Testing scheduled functions​
- Testing authentication with t.withIdentity​
- Mocking fetch calls​
- Asserting results​

The convex-test library provides a mock implementation of the Convex backend in JavaScript. It enables fast automated testing of the logic in your functions.

Example: The library includes a test suite which you can browse to see examples of using it.

Install Vitest and the convex-test library.

Add these scripts to your package.json

Add vitest.config.mts file to configure the test environment to better match the Convex runtime, and to inline the test library for better dependency tracking.

In your convex folder add a file ending in .test.ts

The example test calls the api.messages.send mutation twice and then asserts that the api.messages.list query returns the expected results.

Start the tests with npm run test. When you change the test file or your functions the tests will rerun automatically.

If you're not familiar with Vitest or Jest read the Vitest Getting Started docs first.

The library exports a convexTest function which should be called at the start of each of your tests. The function returns an object which is by convention stored in the t variable and which provides methods for exercising your Convex functions.

If your project uses a schema you should pass it to the convexTest function:

Passing in the schema is required for the tests to correctly implement schema validation and for correct typing of t.run.

If you don't have a schema, call convexTest() with no argument.

Your test can call public and internal Convex functions in your project:

Sometimes you might want to directly write to the mock database or file storage from your test, without needing a declared function in your project. You can use the t.run method which takes a handler that is given a ctx that allows reading from and writing to the mock backend:

Your test can call HTTP actions registered by your router:

Mocking the global fetch function doesn't affect t.fetch, but you can use t.fetch in a fetch mock to route to your HTTP actions.

One advantage of using a mock implementation running purely in JavaScript is that you can control time in the Vitest test environment. To test implementations relying on scheduled functions use Vitest's fake timers in combination with t.finishInProgressScheduledFunctions:

If you have a chain of several scheduled functions, for example a mutation that schedules an action that schedules another action, you can use t.finishAllScheduledFunctions to wait for all scheduled functions, including recursively scheduled functions, to finish:

Check out more examples in this file.

To test functions which depend on the current authenticated user identity you can create a version of the t accessor with given user identity attributes. If you don't provide them, issuer, subject and tokenIdentifier will be generated automatically:

You can use Vitest's vi.stubGlobal method:

See Vitest's Expect reference.

toMatchObject() is particularly helpful when asserting the shape of results without needing to list every object field.

To assert that a function throws, use .rejects.toThrowError():

You can get a printout of the code coverage provided by your tests. Besides answering the question "how much of my code is covered by tests" it is also helpful to check that your test is actually exercising the code that you want it to exercise.

Run npm run test:coverage. It will ask you to install a required dependency the first time you run it.

You can attach a debugger to the running tests. Read the Vitest Debugging docs and then use npm run test:debug.

If you want to use Vitest to test both your Convex functions and your React frontend, you might want to use multiple Vitest environments depending on the test file location via environmentMatchGlobs:

If your project has a different name or location configured for the convex/ folder in convex.json, you need to call import.meta.glob and pass the result as the second argument to convexTest.

The argument to import.meta.glob must be a glob pattern matching all the files containing your Convex functions. The paths are relative to the test file in which import.meta.glob is called. It's best to do this in one place in your custom functions folder:

This example glob pattern includes all files with a single extension ending in s (like js or ts) in the src/convex folder and any of its children.

Use the result in your tests:

Since convex-test is only a mock implementation, it doesn't have many of the behaviors of the real Convex backend. Still, it should be helpful for testing the logic in your functions, and catching regressions caused by changes to your code.

Some of the ways the mock differs:

To test your functions running on a real Convex backend, check out Testing Local Backend.

See Continuous Integration to run your tests on a shared remote machine.

**Examples:**

Example 1 (sh):
```sh
npm install --save-dev convex-test vitest @edge-runtime/vm
```

Example 2 (json):
```json
"scripts": {  "test": "vitest",  "test:once": "vitest run",  "test:debug": "vitest --inspect-brk --no-file-parallelism",  "test:coverage": "vitest run --coverage --coverage.reporter=text",}
```

Example 3 (ts):
```ts
import { defineConfig } from "vitest/config";export default defineConfig({  test: {    environment: "edge-runtime",    server: { deps: { inline: ["convex-test"] } },  },});
```

Example 4 (ts):
```ts
import { convexTest } from "convex-test";import { expect, test } from "vitest";import { api } from "./_generated/api";import schema from "./schema";test("sending messages", async () => {  const t = convexTest(schema);  await t.mutation(api.messages.send, { body: "Hi!", author: "Sarah" });  await t.mutation(api.messages.send, { body: "Hey!", author: "Tom" });  const messages = await t.query(api.messages.list);  expect(messages).toMatchObject([    { body: "Hi!", author: "Sarah" },    { body: "Hey!", author: "Tom" }  ]);});
```

---

## Deployments

**URL:** https://docs.convex.dev/dashboard/deployments/

**Contents:**
- Deployments

Each project in Convex has a main production deployment, and each developer on your team can also set up their own personal development deployment. Additionally, there are preview deployments used to test backend changes before they're deployed to production.

While on a deployment page, you may switch between production, your development deployment, and any preview deployments by using the dropdown menu on the top-left of the page.

---

## Convex Auth

**URL:** https://docs.convex.dev/auth/convex-auth

**Contents:**
- Convex Auth
- Get Started​
- Overview​

Convex Auth is a library for implementing authentication directly within your Convex backend. This allows you to authenticate users without needing an authentication service or even a hosting server. Convex Auth currently supports client-side React web apps served from a CDN and React Native mobile apps.

Example: Live Demo (Source)

Convex Auth is currently a beta feature. If you have feedback or feature requests, let us know on Discord!

Support for authentication in Next.js server components, API routes, middleware, SSR etc. is under active development. If you'd like to help test this experimental support please let us know how it goes in Discord.

To start a new project from scratch with Convex and Convex Auth, run:

and choose React (Vite) and Convex Auth.

To add Convex Auth to an existing project, follow the full setup guide.

Convex Auth enables you to implement the following authentication methods:

The library doesn't come with UI components, but you can copy code from the docs and example repo to quickly build a UI in React.

Learn more in the Convex Auth docs.

**Examples:**

Example 1 (sh):
```sh
npm create convex@latest
```

---

## Error Handling

**URL:** https://docs.convex.dev/functions/error-handling/

**Contents:**
- Error Handling
- Errors in queries​
- Errors in mutations​
- Errors in action functions​
- Differences in error reporting between dev and prod​
- Application errors, expected failures​
- Read/write limit errors​
- Debugging Errors​

There are four reasons why your Convex queries and mutations may hit errors:

Convex will automatically handle internal Convex errors. If there are problems on our end, we'll automatically retry your queries and mutations until the problem is resolved and your queries and mutations succeed.

On the other hand, you must decide how to handle application, developer and read/write limit errors. When one of these errors happens, the best practices are to:

Additionally, you might also want to send client-side errors to a service like Sentry to capture additional information for debugging and observability.

If your query function hits an error, the error will be sent to the client and thrown from your useQuery call site. The best way to handle these errors is with a React error boundary component.

Error boundaries allow you to catch errors thrown in their child component tree, render fallback UI, and send information about the error to your exception handling service. Adding error boundaries to your app is a great way to handle errors in Convex query functions as well as other errors in your React components. If you are using Sentry, you can use their Sentry.ErrorBoundary component.

With error boundaries, you can decide how granular you'd like your fallback UI to be. One simple option is to wrap your entire application in a single error boundary like:

Then any error in any of your components will be caught by the boundary and render the same fallback UI.

On the other hand, if you'd like to enable some portions of your app to continue functioning even if other parts hit errors, you can instead wrap different parts of your app in separate error boundaries.

Unlike other frameworks, there is no concept of "retrying" if your query function hits an error. Because Convex functions are deterministic, if the query function hits an error, retrying will always produce the same error. There is no point in running the query function with the same arguments again.

If a mutation hits an error, this will

If you have an exception service like Sentry configured, it should report "unhandled promise rejections" like this automatically. That means that with no additional work your mutation errors should be reported.

Note that errors in mutations won't be caught by your error boundaries because the error doesn't happen as part of rendering your components.

If you would like to render UI specifically in response to a mutation failure, you can use .catch on your mutation call. For example:

If you're using an async handled function you can also use try...catch:

If you handle your mutation error, it will no longer become an unhandled promise rejection. You may need to report this error to your exception handling service manually.

Unlike queries and mutations, actions may have side-effects and therefore can't be automatically retried by Convex when errors occur. For example, say your action sends a email. If it fails part-way through, Convex has no way of knowing if the email was already sent and can't safely retry the action. It is responsibility of the caller to handle errors raised by actions and retry if appropriate.

Using a dev deployment any server error thrown on the client will include the original error message and a server-side stack trace to ease debugging.

Using a production deployment any server error will be redacted to only include the name of the function and a generic "Server Error" message, with no stack trace. Server application errors will still include their custom data.

Both development and production deployments log full errors with stack traces which can be found on the Logs page of a given deployment.

If you have expected ways your functions might fail, you can either return different values or throw ConvexErrors.

See Application Errors.

To ensure uptime and guarantee performance, Convex will catch queries and mutations that try to read or write too much data. These limits are enforced at the level of a single query or mutation function execution. The limits are:

Queries and mutations error out when:

In addition, mutations error out when:

Documents are "scanned" by the database to figure out which documents should be returned from db.query. So for example db.query("table").take(5).collect() will only need to scan 5 documents, but db.query("table").filter(...).first() might scan up to as many documents as there are in "table", to find the first one that matches the given filter.

Number of calls to db.get and db.query has a limit to prevent a single query from subscribing to too many index ranges.

In general, if you're running into these limits frequently, we recommend indexing your queries to reduce the number of documents scanned, allowing you to avoid unnecessary reads. Queries that scan large swaths of your data may look innocent at first, but can easily blow up at any production scale. If your functions are close to hitting these limits they will log a warning.

For information on other limits, see here.

See Debugging and specifically Finding relevant logs by Request ID.

**Examples:**

Example 1 (tsx):
```tsx
<StrictMode>  <ErrorBoundary>    <ConvexProvider client={convex}>      <App />    </ConvexProvider>  </ErrorBoundary></StrictMode>,
```

Example 2 (javascript):
```javascript
sendMessage(newMessageText).catch((error) => {  // Do something with `error` here});
```

Example 3 (javascript):
```javascript
try {  await sendMessage(newMessageText);} catch (error) {  // Do something with `error` here}
```

---

## HTTP Actions

**URL:** https://docs.convex.dev/functions/http-actions

**Contents:**
- HTTP Actions
- Defining HTTP actions​
- Limits​
- Debugging​
  - Step 1: Check that your HTTP actions were deployed.​
  - Step 2: Check that you can access your endpoint using curl​
  - Step 3: Check the request being made by your browser​
- Common patterns​
  - File Storage​
  - CORS​

HTTP actions allow you to build an HTTP API right in Convex!

HTTP actions take in a Request and return a Response following the Fetch API. HTTP actions can manipulate the request and response directly, and interact with data in Convex indirectly by running queries, mutations, and actions. HTTP actions might be used for receiving webhooks from external applications or defining a public HTTP API.

HTTP actions are exposed at https://<your deployment name>.convex.site (e.g. https://happy-animal-123.convex.site).

Example: HTTP Actions

HTTP action handlers are defined using the httpAction constructor, similar to the action constructor for normal actions:

The first argument to the handler is an ActionCtx object, which provides auth, storage, and scheduler, as well as runQuery, runMutation, runAction.

The second argument contains the Request data. HTTP actions do not support argument validation, as the parsing of arguments from the incoming Request is left entirely to you.

To expose the HTTP Action, export an instance of HttpRouter from the convex/http.ts file. To create the instance call the httpRouter function. On the HttpRouter you can expose routes using the route method:

You can now call this action via HTTP and interact with data stored in the Convex Database. HTTP actions are exposed on https://<your deployment name>.convex.site.

Like other Convex functions, you can view your HTTP actions in the Functions view of your dashboard and view logs produced by them in the Logs view.

HTTP actions run in the same environment as queries and mutations so also do not have access to Node.js-specific JavaScript APIs. HTTP actions can call actions, which can run in Node.js.

Like actions, HTTP actions may have side-effects and will not be automatically retried by Convex when errors occur. It is a responsibility of the caller to handle errors and retry the request if appropriate.

Request and response size is limited to 20MB.

HTTP actions support request and response body types of .text(), .json(), .blob(), and .arrayBuffer().

Note that you don't need to define an HTTP action to call your queries, mutations and actions over HTTP if you control the caller, since you can use use the JavaScript ConvexHttpClient or the Python client to call these functions directly.

Check the functions page in the dashboard and make sure there's an entry called http.

If not, double check that you've defined your HTTP actions with the httpRouter in a file called http.js or http.ts (the name of the file must match exactly), and that npx convex dev has no errors.

Get your URL from the dashboard under Settings > URL and Deploy Key.

Make sure this is the URL that ends in .convex.site, and not .convex.cloud. E.g. https://happy-animal-123.convex.site

Run a curl command to hit one of your defined endpoints, potentially defining a new endpoint specifically for testing

Check the logs page in the dashboard to confirm that there's an entry for your HTTP action.

If you've determined that your HTTP actions have been deployed and are accessible via curl, but there are still issues requesting them from your app, check the exact requests being made by your browser.

Open the Network tab in your browser's developer tools, and trigger your HTTP requests.

Check that this URL matches what you tested earlier with curl -- it ends in .convex.site and has the right deployment name.

You should be able to see these requests in the dashboard logs page.

If you see "CORS error" or messages in the browser console like Access to fetch at '...' from origin '...' has been blocked by CORS policy, you likely need to configure CORS headers and potentially add a handler for the pre-flight OPTIONS request. See this section below.

HTTP actions can be used to handle uploading and fetching stored files, see:

To make requests to HTTP actions from a website you need to add Cross-Origin Resource Sharing (CORS) headers to your HTTP actions.

There are existing resources for exactly which CORS headers are required based on the use case. This site provides an interactive walkthrough for what CORS headers to add. Here's an example of adding CORS headers to a Convex HTTP action:

Here's an example of handling a pre-flight OPTIONS request:

You can leverage Convex's built-in authentication integration and access a user identity from ctx.auth.getUserIdentity(). To do this call your endpoint with an Authorization header including a JWT token:

**Examples:**

Example 1 (ts):
```ts
import { httpRouter } from "convex/server";import { httpAction } from "./_generated/server";const http = httpRouter();http.route({  path: "/",  method: "GET",  handler: httpAction(async (ctx, request) => {    return new Response(`Hello from ${request.url}`);  }),});export default http;
```

Example 2 (ts):
```ts
import { httpAction } from "./_generated/server";export const doSomething = httpAction(async () => {  // implementation will be here  return new Response();});
```

Example 3 (ts):
```ts
import { httpAction } from "./_generated/server";import { internal } from "./_generated/api";export const postMessage = httpAction(async (ctx, request) => {  const { author, body } = await request.json();  await ctx.runMutation(internal.messages.sendOne, {    body: `Sent via HTTP action: ${body}`,    author,  });  return new Response(null, {    status: 200,  });});
```

Example 4 (ts):
```ts
import { httpRouter } from "convex/server";import { postMessage, getByAuthor, getByAuthorPathSuffix } from "./messages";const http = httpRouter();http.route({  path: "/postMessage",  method: "POST",  handler: postMessage,});// Define additional routeshttp.route({  path: "/getMessagesByAuthor",  method: "GET",  handler: getByAuthor,});// Define a route using a path prefixhttp.route({  // Will match /getAuthorMessages/User+123 and /getAuthorMessages/User+234 etc.  pathPrefix: "/getAuthorMessages/",  method: "GET",  handler: getByAuthorPathSuffix,});// Convex expects the router to be the default export of `convex/http.js`.export default http;
```

---

## Vector Search

**URL:** https://docs.convex.dev/vector-search

**Contents:**
- Vector Search
- Defining vector indexes​
- Running vector searches​
  - Filter expressions​
  - Other filtering​
  - Ordering​
- Advanced patterns​
  - Using a separate table to store vectors​
  - Fetching results and adding new documents​
- Limits​

Vector search allows you to find Convex documents similar to a provided vector. Typically, vectors will be embeddings which are numerical representations of text, images, or audio.

Embeddings and vector search enable you to provide useful context to LLMs for AI powered applications, recommendations for similar content and more.

Vector search is consistent and fully up-to-date. You can write a vector and immediately read it from a vector search. Unlike full text search, however, vector search is only available in Convex actions.

Example: Vector Search App

To use vector search you need to:

Like database indexes, vector indexes are a data structure that is built in advance to enable efficient querying. Vector indexes are defined as part of your Convex schema.

To add a vector index onto a table, use the vectorIndex method on your table's schema. Every vector index has a unique name and a definition with:

For example, if you want an index that can search for similar foods within a given cuisine, your table definition could look like:

You can specify vector and filter fields on nested documents by using a dot-separated path like properties.name.

Unlike database queries or full text search, vector searches can only be performed in a Convex action.

They generally involve three steps:

Here's an example of the first two steps for searching for similar French foods based on a description:

An example of the first step can be found here in the vector search demo app.

Focusing on the second step, the vectorSearch API takes in the table name, the index name, and finally a VectorSearchQuery object describing the search. This object has the following fields:

It returns an Array of objects containing exactly two fields:

Neither the underlying document nor the vector are included in results, so once you have the list of results, you will want to load the desired information about the results.

There are a few strategies for loading this information documented in the Advanced Patterns section.

For now, let's load the documents and return them from the action. To do so, we'll pass the list of results to a Convex query and run it inside of our action, returning the result:

As mentioned above, vector searches support efficiently filtering results by additional fields on your document using either exact equality on a single field, or an OR of expressions.

For example, here's a filter for foods with cuisine exactly equal to "French":

You can also filter documents by a single field that contains several different values using an or expression. Here's a filter for French or Indonesian dishes:

For indexes with multiple filter fields, you can also use .or() filters on different fields. Here's a filter for dishes whose cuisine is French or whose main ingredient is butter:

Both cuisine and mainIngredient would need to be included in the filterFields in the .vectorIndex definition.

Results can be filtered based on how similar they are to the provided vector using the _score field in your action:

Additional filtering can always be done by passing the vector search results to a query or mutation function that loads the documents and performs filtering using any of the fields on the document.

For performance, always put as many of your filters as possible into .vectorSearch.

Vector queries always return results in relevance order.

Currently Convex searches vectors using an approximate nearest neighbor search based on cosine similarity. Support for more similarity metrics will come in the future.

If multiple documents have the same score, ties are broken by the document ID.

There are two main options for setting up a vector index:

The examples above show the first option, which is simpler and works well for reading small amounts of documents. The second option is more complex, but better supports reading or returning large amounts of documents.

Since vectors are typically large and not useful beyond performing vector searches, it's nice to avoid loading them from the database when reading other data (e.g. db.get()) or returning them from functions by storing them in a separate table.

A table definition for movies, and a vector index supporting search for similar movies filtering by genre would look like this:

Generating an embedding and running a vector search are the same as using a single table. Loading the relevant documents given the vector search result is different since we have an ID for movieEmbeddings but want to load a movies document. We can do this using the by_embedding database index on the movies table:

Returning information from a vector search involves an action (since vector search is only available in actions) and a query or mutation to load the data.

The example above used a query to load data and return it from an action. Since this is an action, the data returned is not reactive. An alternative would be to return the results of the vector search in the action, and have a separate query that reactively loads the data. The search results will not update reactively, but the data about each result would be reactive.

The Vector Search Demo App uses this strategy to show similar movies with a reactive "Votes" count.

Convex supports millions of vectors today. This is an ongoing project and we will continue to scale this offering out with the rest of Convex.

Vector indexes must have:

Vector indexes count towards the limit of 32 indexes per table. In addition you can have up to 4 vector indexes per table.

Vector searches can have:

If your action performs a vector search then passes the results to a query or mutation function, you may find that one or more results from the vector search have been deleted or mutated. Because vector search is only available in actions, you cannot perform additional transactional queries or mutations based on the results. If this is important for your use case, please let us know on Discord!

Only documents that contain a vector of the size and in the field specified by a vector index will be included in the index and returned by the vector search.

For information on limits, see here.

We're always open to customer feedback and requests. Some ideas we've considered for improving vector search in Convex include:

If any of these features is important for your app, let us know on Discord!

**Examples:**

Example 1 (ts):
```ts
foods: defineTable({  description: v.string(),  cuisine: v.string(),  embedding: v.array(v.float64()),}).vectorIndex("by_embedding", {  vectorField: "embedding",  dimensions: 1536,  filterFields: ["cuisine"],}),
```

Example 2 (ts):
```ts
import { v } from "convex/values";import { action } from "./_generated/server";export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // ...  },});
```

Example 3 (ts):
```ts
export const fetchResults = internalQuery({  args: { ids: v.array(v.id("foods")) },  handler: async (ctx, args) => {    const results = [];    for (const id of args.ids) {      const doc = await ctx.db.get(id);      if (doc === null) {        continue;      }      results.push(doc);    }    return results;  },});
```

Example 4 (ts):
```ts
export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // 3. Fetch the results    const foods: Array<Doc<"foods">> = await ctx.runQuery(      internal.foods.fetchResults,      { ids: results.map((result) => result._id) },    );    return foods;  },});
```

---
