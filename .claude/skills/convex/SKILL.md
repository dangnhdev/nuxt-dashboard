---
name: convex
description: Convex documentation - backend as a service platform
---

# Convex Skill

Comprehensive assistance with convex development, generated from official documentation.

## When to Use This Skill

This skill should be triggered when:
- Working with convex
- Asking about convex features or APIs
- Implementing convex solutions
- Debugging convex code
- Learning convex best practices

## Quick Reference

### Common Patterns

**Pattern 1:** Uploading and Storing FilesUpload files to Convex by generated upload urls, or via an custom HTTP Action. Uploading files via upload URLs​ Arbitrarily large files can be uploaded directly to your backend using a generated upload URL. This requires the client to make 3 requests: Generate an upload URL using a mutation that calls storage.generateUploadUrl(). Send a POST request with the file contents to the upload URL and receive a storage ID. Save the storage ID into your data model via another mutation. In the first mutation that generates the upload URL you can control who can upload files to your Convex storage. Example: File Storage with Queries and Mutations Calling the upload APIs from a web page​ Here's an example of uploading an image via a form submission handler to an upload URL generated by a mutation: src/App.tsxTSimport { FormEvent, useRef, useState } from "react";import { useMutation } from "convex/react";import { api } from "../convex/_generated/api";export default function App() { const generateUploadUrl = useMutation(api.messages.generateUploadUrl); const sendImage = useMutation(api.messages.sendImage); const imageInput = useRef<HTMLInputElement>(null); const [selectedImage, setSelectedImage] = useState<File | null>(null); const [name] = useState(() => "User " + Math.floor(Math.random() * 10000)); async function handleSendImage(event: FormEvent) { event.preventDefault(); // Step 1: Get a short-lived upload URL const postUrl = await generateUploadUrl(); // Step 2: POST the file to the URL const result = await fetch(postUrl, { method: "POST", headers: { "Content-Type": selectedImage!.type }, body: selectedImage, }); const { storageId } = await result.json(); // Step 3: Save the newly allocated storage id to the database await sendImage({ storageId, author: name }); setSelectedImage(null); imageInput.current!.value = ""; } return ( <form onSubmit={handleSendImage}> <input type="file" accept="image/*" ref={imageInput} onChange={(event) => setSelectedImage(event.target.files![0])} disabled={selectedImage !== null} /> <input type="submit" value="Send Image" disabled={selectedImage === null} /> </form> );} Generating the upload URL​ An upload URL can be generated by the storage.generateUploadUrl function of the MutationCtx object: convex/messages.tsTSimport { mutation } from "./_generated/server";export const generateUploadUrl = mutation({ handler: async (ctx) => { return await ctx.storage.generateUploadUrl(); },}); This mutation can control who is allowed to upload files. The upload URL expires in 1 hour and so should be fetched shortly before the upload is made. Writing the new storage ID to the database​ Since the storage ID is returned to the client it is likely you will want to persist it in the database via another mutation: convex/messages.tsTSimport { mutation } from "./_generated/server";export const sendImage = mutation({ args: { storageId: v.id("_storage"), author: v.string() }, handler: async (ctx, args) => { await ctx.db.insert("messages", { body: args.storageId, author: args.author, format: "image", }); },}); Limits​ The file size is not limited, but upload POST request has a 2 minute timeout. Uploading files via an HTTP action​ The file upload process can be more tightly controlled by leveraging HTTP actions, performing the whole upload flow using a single request, but requiring correct CORS headers configuration. The custom upload HTTP action can control who can upload files to your Convex storage. But note that the HTTP action request size is currently limited to 20MB. For larger files you need to use upload URLs as described above. Example: File Storage with HTTP Actions Calling the upload HTTP action from a web page​ Here's an example of uploading an image via a form submission handler to the sendImage HTTP action defined next. The highlighted lines make the actual request to the HTTP action: src/App.tsxTSimport { FormEvent, useRef, useState } from "react";const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;export default function App() { const imageInput = useRef<HTMLInputElement>(null); const [selectedImage, setSelectedImage] = useState<File | null>(null); async function handleSendImage(event: FormEvent) { event.preventDefault(); // e.g. https://happy-animal-123.convex.site/sendImage?author=User+123 const sendImageUrl = new URL(`${convexSiteUrl}/sendImage`); sendImageUrl.searchParams.set("author", "Jack Smith"); await fetch(sendImageUrl, { method: "POST", headers: { "Content-Type": selectedImage!.type }, body: selectedImage, }); setSelectedImage(null); imageInput.current!.value = ""; } return ( <form onSubmit={handleSendImage}> <input type="file" accept="image/*" ref={imageInput} onChange={(event) => setSelectedImage(event.target.files![0])} disabled={selectedImage !== null} /> <input type="submit" value="Send Image" disabled={selectedImage === null} /> </form> );} Defining the upload HTTP action​ A file sent in the HTTP request body can be stored using the storage.store function of the ActionCtx object. This function returns an Id<"_storage"> of the stored file. From the HTTP action you can call a mutation to write the storage ID to a document in your database. To confirm success back to your hosted website, you will need to set the right CORS headers: convex/http.tsTSimport { httpRouter } from "convex/server";import { httpAction } from "./_generated/server";import { api } from "./_generated/api";import { Id } from "./_generated/dataModel";const http = httpRouter();http.route({ path: "/sendImage", method: "POST", handler: httpAction(async (ctx, request) => { // Step 1: Store the file const blob = await request.blob(); const storageId = await ctx.storage.store(blob); // Step 2: Save the storage ID to the database via a mutation const author = new URL(request.url).searchParams.get("author"); await ctx.runMutation(api.messages.sendImage, { storageId, author }); // Step 3: Return a response with the correct CORS headers return new Response(null, { status: 200, // CORS headers headers: new Headers({ // e.g. https://mywebsite.com, configured on your Convex dashboard "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!, Vary: "origin", }), }); }),}); You also need to handle the pre-flight OPTIONS request: convex/http.tsTS// Pre-flight request for /sendImagehttp.route({ path: "/sendImage", method: "OPTIONS", handler: httpAction(async (_, request) => { // Make sure the necessary headers are present // for this to be a valid pre-flight request const headers = request.headers; if ( headers.get("Origin") !== null && headers.get("Access-Control-Request-Method") !== null && headers.get("Access-Control-Request-Headers") !== null ) { return new Response(null, { headers: new Headers({ // e.g. https://mywebsite.com, configured on your Convex dashboard "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!, "Access-Control-Allow-Methods": "POST", "Access-Control-Allow-Headers": "Content-Type, Digest", "Access-Control-Max-Age": "86400", }), }); } else { return new Response(); } }),});

```
storage.generateUploadUrl()
```

**Pattern 2:** Example: File Storage with HTTP Actions

```
sendImage
```

**Pattern 3:** Convex & Auth0Auth0 is an authentication platform providing login via passwords, social identity providers, one-time email or SMS access codes, multi-factor authentication, and single sign on and basic user management. Example: Convex Authentication with Auth0 If you're using Next.js see the Next.js setup guide. Get started​ This guide assumes you already have a working React app with Convex. If not follow the Convex React Quickstart first. Then: Follow the Auth0 React quickstartFollow the Auth0 React Quickstart.Sign up for a free Auth0 account.Configure your application, using http://localhost:3000, http://localhost:5173 for Callback and Logout URLs and Allowed Web Origins.Come back when you finish the Install the Auth0 React SDK step.Create the auth configIn the convex folder create a new file auth.config.ts with the server-side configuration for validating access tokens.Paste in the domain and clientId values shown in Install the Auth0 React SDK step of the Auth0 quickstart or in your Auth0 application's Settings dashboard.convex/auth.config.tsTSimport { AuthConfig } from "convex/server";export default { providers: [ { domain: "your-domain.us.auth0.com", applicationID: "yourclientid", }, ]} satisfies AuthConfig;Deploy your changesRun npx convex dev to automatically sync your configuration to your backend.npx convex devConfigure ConvexProviderWithAuth0Now replace your ConvexProvider with an Auth0Provider wrapping ConvexProviderWithAuth0. Add the domain and clientId as props to the Auth0Provider.Paste in the domain and clientId values shown in Install the Auth0 React SDK step of the Auth0 quickstart or in your Auth0 application's Settings dashboard as props to Auth0Provider.src/main.tsxTSimport React from "react";import ReactDOM from "react-dom/client";import App from "./App";import "./index.css";import { ConvexReactClient } from "convex/react";import { ConvexProviderWithAuth0 } from "convex/react-auth0";import { Auth0Provider } from "@auth0/auth0-react";const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);ReactDOM.createRoot(document.getElementById("root")!).render( <React.StrictMode> <Auth0Provider domain="your-domain.us.auth0.com" clientId="yourclientid" authorizationParams={{ redirect_uri: window.location.origin, }} useRefreshTokens={true} cacheLocation="localstorage" > <ConvexProviderWithAuth0 client={convex}> <App /> </ConvexProviderWithAuth0> </Auth0Provider> </React.StrictMode>,); Login and logout flows​ Now that you have everything set up, you can use the useAuth0() hook to create login and logout buttons for your app. The login button will redirect the user to the Auth0 universal login page. For details see Add Login to Your Application in the Auth0 React Quickstart. src/login.tsTSimport { useAuth0 } from "@auth0/auth0-react";export default function LoginButton() { const { loginWithRedirect } = useAuth0(); return <button onClick={loginWithRedirect}>Log in</button>;} The logout button will redirect the user to the Auth0 logout endpoint. For details see Add Logout to your Application in the Auth0 React Quickstart. src/logout.tsTSimport { useAuth0 } from "@auth0/auth0-react";export default function LogoutButton() { const { logout } = useAuth0(); return ( <button onClick={() => logout({ logoutParams: { returnTo: window.location.origin } }) } > Log out </button> );} Logged-in and logged-out views​ Use the useConvexAuth() hook instead of the useAuth0 hook when you need to check whether the user is logged in or not. The useConvex hook makes sure that the browser has fetched the auth token needed to make authenticated requests to your Convex backend: src/App.tsTSimport { useConvexAuth } from "convex/react";function App() { const { isLoading, isAuthenticated } = useConvexAuth(); return ( <div className="App"> {isAuthenticated ? "Logged in" : "Logged out or still loading"} </div> );} You can also use the Authenticated, Unauthenticated and AuthLoading helper components which use the useConvexAuth hook under the hood: src/App.tsTSimport { Authenticated, Unauthenticated, AuthLoading } from "convex/react";function App() { return ( <div className="App"> <Authenticated>Logged in</Authenticated> <Unauthenticated>Logged out</Unauthenticated> <AuthLoading>Still loading</AuthLoading> </div> );} User information in React​ You can access information about the authenticated user like their name from the useAuth0 hook: src/badge.tsTSimport { useAuth0 } from "@auth0/auth0-react";export default function Badge() { const { user } = useAuth0(); return <span>Logged in as {user.name}</span>;} User information in functions​ See Auth in Functions to learn about how to access information about the authenticated user in your queries, mutations and actions. See Storing Users in the Convex Database to learn about how to store user information in the Convex database. Configuring dev and prod tenants​ To configure a different Auth0 tenant (environment) between your Convex development and production deployments you can use environment variables configured on the Convex dashboard. Configuring the backend​ First, change your auth.config.ts file to use environment variables: convex/auth.config.tsTSimport { AuthConfig } from "convex/server";export default { providers: [ { domain: process.env.AUTH0_DOMAIN!, applicationID: process.env.AUTH0_CLIENT_ID!, }, ],} satisfies AuthConfig; Development configuration Open the Settings for your dev deployment on the Convex dashboard and add the variables there: Now switch to the new configuration by running npx convex dev. Production configuration Similarly on the Convex dashboard switch to your production deployment in the left side menu and set the values for your production Auth0 tenant there. Now switch to the new configuration by running npx convex deploy. Configuring a React client​ To configure your client you can use environment variables as well. The exact name of the environment variables and the way to refer to them depends on each client platform (Vite vs Next.js etc.), refer to our corresponding Quickstart or the relevant documentation for the platform you're using. Change the props to Auth0Provider to take in environment variables: src/main.tsxTSimport React from "react";import ReactDOM from "react-dom/client";import App from "./App";import "./index.css";import { ConvexReactClient } from "convex/react";import { ConvexProviderWithAuth0 } from "convex/react-auth0";import { Auth0Provider } from "@auth0/auth0-react";const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);ReactDOM.createRoot(document.getElementById("root")!).render( <React.StrictMode> <Auth0Provider domain={import.meta.env.VITE_AUTH0_DOMAIN} clientId={import.meta.env.VITE_AUTH0_CLIENT_ID} authorizationParams={{ redirect_uri: window.location.origin, }} useRefreshTokens={true} cacheLocation="localstorage" > <ConvexProviderWithAuth0 client={convex}> <App /> </ConvexProviderWithAuth0> </Auth0Provider> </React.StrictMode>,); Development configuration Use the .env.local or .env file to configure your client when running locally. The name of the environment variables file depends on each client platform (Vite vs Next.js etc.), refer to our corresponding Quickstart or the relevant documentation for the platform you're using: .env.localVITE_AUTH0_DOMAIN="your-domain.us.auth0.com"VITE_AUTH0_CLIENT_ID="yourclientid" Production configuration Set the environment variables in your production environment depending on your hosting platform. See Hosting. Debugging authentication​ If a user goes through the Auth0 login flow successfully, and after being redirected back to your page useConvexAuth gives isAuthenticated: false, it's possible that your backend isn't correctly configured. The auth.config.ts file in your convex/ directory contains a list of configured authentication providers. You must run npx convex dev or npx convex deploy after adding a new provider to sync the configuration to your backend. For more thorough debugging steps, see Debugging Authentication. Under the hood​ The authentication flow looks like this under the hood: The user clicks a login button The user is redirected to a page where they log in via whatever method you configure in Auth0 After a successful login Auth0 redirects back to your page, or a different page which you configure via the authorizationParams prop. The Auth0Provider now knows that the user is authenticated. The ConvexProviderWithAuth0 fetches an auth token from Auth0. The ConvexReactClient passes this token down to your Convex backend to validate Your Convex backend retrieves the public key from Auth0 to check that the token's signature is valid. The ConvexReactClient is notified of successful authentication, and ConvexProviderWithAuth0 now knows that the user is authenticated with Convex. useConvexAuth returns isAuthenticated: true and the Authenticated component renders its children. ConvexProviderWithAuth0 takes care of refetching the token when needed to make sure the user stays authenticated with your backend.

```
http://localhost:3000, http://localhost:5173
```

**Pattern 4:** Internal FunctionsInternal functions can only be called by other functions and cannot be called directly from a Convex client. By default your Convex functions are public and accessible to clients. Public functions may be called by malicious users in ways that cause surprising results. Internal functions help you mitigate this risk. We recommend using internal functions any time you're writing logic that should not be called from a client. While internal functions help mitigate risk by reducing the public surface area of your application, you can still validate internal invariants using argument validation and/or authentication. Use cases for internal functions​ Leverage internal functions by: Calling them from actions via runQuery and runMutation Calling them from HTTP actions via runQuery, runMutation, and runAction Scheduling them from other functions to run in the future Scheduling them to run periodically from cron jobs Running them using the Dashboard Running them from the CLI Defining internal functions​ An internal function is defined using internalQuery, internalMutation, or internalAction. For example: convex/plans.tsTSimport { internalMutation } from "./_generated/server";import { v } from "convex/values";export const markPlanAsProfessional = internalMutation({ args: { planId: v.id("plans") }, handler: async (ctx, args) => { await ctx.db.patch(args.planId, { planType: "professional" }); },}); If you need to pass complicated objects to internal functions you might prefer to not use argument validation. Note though that if you're using internalQuery or internalMutation it's a better idea to pass around document IDs instead of documents, to ensure the query or mutation is working with the up-to-date state of the database. Internal function without argument validationconvex/plans.tsTSimport { internalAction } from "./_generated/server";import { Doc } from "./_generated/dataModel";export const markPlanAsProfessional = internalAction({ handler: async (actionCtx, args) => { // perform an action, perhaps calling a third-party API },}); Calling internal functions​ Internal functions can be called from actions and scheduled from actions and mutation using the internal object. For example, consider this public upgrade action that calls the internal plans.markPlanAsProfessional mutation we defined above: convex/changes.tsTSimport { action } from "./_generated/server";import { internal } from "./_generated/api";import { v } from "convex/values";export const upgrade = action({ args: { planId: v.id("plans"), }, handler: async (ctx, args) => { // Call out to payment provider (e.g. Stripe) to charge customer const response = await fetch("https://..."); if (response.ok) { // Mark the plan as "professional" in the Convex DB await ctx.runMutation(internal.plans.markPlanAsProfessional, { planId: args.planId, }); } },}); In this example a user should not be able to directly call internal.plans.markPlanAsProfessional without going through the upgrade action — if they did, then they would get a free upgrade. You can define public and internal functions in the same file.

```
runQuery
```

**Pattern 5:** An internal function is defined using internalQuery, internalMutation, or internalAction. For example:

```
internalQuery
```

**Pattern 6:** Module: reactTools to integrate Convex into React applications. This module contains: ConvexReactClient, a client for using Convex in React. ConvexProvider, a component that stores this client in React context. Authenticated, Unauthenticated and AuthLoading helper auth components. Hooks useQuery, useMutation, useAction and more for accessing this client from your React components. Usage​ Creating the client​ import { ConvexReactClient } from "convex/react";// typically loaded from an environment variableconst address = "https://small-mouse-123.convex.cloud"const convex = new ConvexReactClient(address); Storing the client in React Context​ import { ConvexProvider } from "convex/react";<ConvexProvider client={convex}> <App /></ConvexProvider> Using the auth helpers​ import { Authenticated, Unauthenticated, AuthLoading } from "convex/react";<Authenticated> Logged in</Authenticated><Unauthenticated> Logged out</Unauthenticated><AuthLoading> Still loading</AuthLoading> Using React hooks​ import { useQuery, useMutation } from "convex/react";import { api } from "../convex/_generated/api";function App() { const counter = useQuery(api.getCounter.default); const increment = useMutation(api.incrementCounter.default); // Your component here!} Classes​ ConvexReactClient Interfaces​ ReactMutation ReactAction Watch WatchQueryOptions MutationOptions ConvexReactClientOptions References​ AuthTokenFetcher​ Re-exports AuthTokenFetcher Type Aliases​ ConvexAuthState​ Ƭ ConvexAuthState: Object Type representing the state of an auth integration with Convex. Type declaration​ NameTypeisLoadingbooleanisAuthenticatedboolean Defined in​ react/ConvexAuthState.tsx:26 OptionalRestArgsOrSkip​ Ƭ OptionalRestArgsOrSkip<FuncRef>: FuncRef["_args"] extends EmptyObject ? [args?: EmptyObject | "skip"] : [args: FuncRef["_args"] | "skip"] Type parameters​ NameTypeFuncRefextends FunctionReference<any> Defined in​ react/client.ts:640 Preloaded​ Ƭ Preloaded<Query>: Object The preloaded query payload, which should be passed to a client component and passed to usePreloadedQuery. Type parameters​ NameTypeQueryextends FunctionReference<"query"> Type declaration​ NameType__typeQuery_namestring_argsJSONstring_valueJSONstring Defined in​ react/hydration.tsx:12 PaginatedQueryReference​ Ƭ PaginatedQueryReference: FunctionReference<"query", "public", { paginationOpts: PaginationOptions }, PaginationResult<any>> A FunctionReference that is usable with usePaginatedQuery. This function reference must: Refer to a public query Have an argument named "paginationOpts" of type PaginationOptions Have a return type of PaginationResult. Defined in​ react/use_paginated_query.ts:31 UsePaginatedQueryResult​ Ƭ UsePaginatedQueryResult<Item>: { results: Item[] ; loadMore: (numItems: number) => void } & { status: "LoadingFirstPage" ; isLoading: true } | { status: "CanLoadMore" ; isLoading: false } | { status: "LoadingMore" ; isLoading: true } | { status: "Exhausted" ; isLoading: false } The result of calling the usePaginatedQuery hook. This includes: results - An array of the currently loaded results. isLoading - Whether the hook is currently loading results. status - The status of the pagination. The possible statuses are: "LoadingFirstPage": The hook is loading the first page of results. "CanLoadMore": This query may have more items to fetch. Call loadMore to fetch another page. "LoadingMore": We're currently loading another page of results. "Exhausted": We've paginated to the end of the list. loadMore(n) A callback to fetch more results. This will only fetch more results if the status is "CanLoadMore". Type parameters​ NameItem Defined in​ react/use_paginated_query.ts:479 PaginationStatus​ Ƭ PaginationStatus: UsePaginatedQueryResult<any>["status"] The possible pagination statuses in UsePaginatedQueryResult. This is a union of string literal types. Defined in​ react/use_paginated_query.ts:507 PaginatedQueryArgs​ Ƭ PaginatedQueryArgs<Query>: Expand<BetterOmit<FunctionArgs<Query>, "paginationOpts">> Given a PaginatedQueryReference, get the type of the arguments object for the query, excluding the paginationOpts argument. Type parameters​ NameTypeQueryextends PaginatedQueryReference Defined in​ react/use_paginated_query.ts:515 PaginatedQueryItem​ Ƭ PaginatedQueryItem<Query>: FunctionReturnType<Query>["page"][number] Given a PaginatedQueryReference, get the type of the item being paginated over. Type parameters​ NameTypeQueryextends PaginatedQueryReference Defined in​ react/use_paginated_query.ts:524 UsePaginatedQueryReturnType​ Ƭ UsePaginatedQueryReturnType<Query>: UsePaginatedQueryResult<PaginatedQueryItem<Query>> The return type of usePaginatedQuery. Type parameters​ NameTypeQueryextends PaginatedQueryReference Defined in​ react/use_paginated_query.ts:532 RequestForQueries​ Ƭ RequestForQueries: Record<string, { query: FunctionReference<"query"> ; args: Record<string, Value> }> An object representing a request to load multiple queries. The keys of this object are identifiers and the values are objects containing the query function and the arguments to pass to it. This is used as an argument to useQueries. Defined in​ react/use_queries.ts:126 Functions​ useConvexAuth​ ▸ useConvexAuth(): Object Get the ConvexAuthState within a React component. This relies on a Convex auth integration provider being above in the React component tree. Returns​ Object The current ConvexAuthState. NameTypeisLoadingbooleanisAuthenticatedboolean Defined in​ react/ConvexAuthState.tsx:43 ConvexProviderWithAuth​ ▸ ConvexProviderWithAuth(«destructured»): Element A replacement for ConvexProvider which additionally provides ConvexAuthState to descendants of this component. Use this to integrate any auth provider with Convex. The useAuth prop should be a React hook that returns the provider's authentication state and a function to fetch a JWT access token. If the useAuth prop function updates causing a rerender then auth state will transition to loading and the fetchAccessToken() function called again. See Custom Auth Integration for more information. Parameters​ NameType«destructured»Object› children?ReactNode› clientIConvexReactClient› useAuth() => { isLoading: boolean ; isAuthenticated: boolean ; fetchAccessToken: (args: { forceRefreshToken: boolean }) => Promise<null | string> } Returns​ Element Defined in​ react/ConvexAuthState.tsx:75 Authenticated​ ▸ Authenticated(«destructured»): null | Element Renders children if the client is authenticated. Parameters​ NameType«destructured»Object› childrenReactNode Returns​ null | Element Defined in​ react/auth_helpers.tsx:10 Unauthenticated​ ▸ Unauthenticated(«destructured»): null | Element Renders children if the client is using authentication but is not authenticated. Parameters​ NameType«destructured»Object› childrenReactNode Returns​ null | Element Defined in​ react/auth_helpers.tsx:23 AuthLoading​ ▸ AuthLoading(«destructured»): null | Element Renders children if the client isn't using authentication or is in the process of authenticating. Parameters​ NameType«destructured»Object› childrenReactNode Returns​ null | Element Defined in​ react/auth_helpers.tsx:37 useConvex​ ▸ useConvex(): ConvexReactClient Get the ConvexReactClient within a React component. This relies on the ConvexProvider being above in the React component tree. Returns​ ConvexReactClient The active ConvexReactClient object, or undefined. Defined in​ react/client.ts:615 ConvexProvider​ ▸ ConvexProvider(props, deprecatedLegacyContext?): null | ReactElement<any, any> Provides an active Convex ConvexReactClient to descendants of this component. Wrap your app in this component to use Convex hooks useQuery, useMutation, and useConvex. Parameters​ NameTypeDescriptionpropsObjectan object with a client property that refers to a ConvexReactClient.props.clientConvexReactClient-props.children?ReactNode-deprecatedLegacyContext?anyDeprecated See React Docs Returns​ null | ReactElement<any, any> Defined in​ ../../common/temp/node_modules/.pnpm/@types+react@18.3.18/node_modules/@types/react/ts5.0/index.d.ts:1128 useQuery​ ▸ useQuery<Query>(query, ...args): Query["_returnType"] | undefined Load a reactive query within a React component. This React hook contains internal state that will cause a rerender whenever the query result changes. Throws an error if not used under ConvexProvider. Type parameters​ NameTypeQueryextends FunctionReference<"query"> Parameters​ NameTypeDescriptionqueryQuerya FunctionReference for the public query to run like api.dir1.dir2.filename.func....argsOptionalRestArgsOrSkip<Query>The arguments to the query function or the string "skip" if the query should not be loaded. Returns​ Query["_returnType"] | undefined the result of the query. If the query is loading returns undefined. Defined in​ react/client.ts:661 useMutation​ ▸ useMutation<Mutation>(mutation): ReactMutation<Mutation> Construct a new ReactMutation. Mutation objects can be called like functions to request execution of the corresponding Convex function, or further configured with optimistic updates. The value returned by this hook is stable across renders, so it can be used by React dependency arrays and memoization logic relying on object identity without causing rerenders. Throws an error if not used under ConvexProvider. Type parameters​ NameTypeMutationextends FunctionReference<"mutation"> Parameters​ NameTypeDescriptionmutationMutationA FunctionReference for the public mutation to run like api.dir1.dir2.filename.func. Returns​ ReactMutation<Mutation> The ReactMutation object with that name. Defined in​ react/client.ts:713 useAction​ ▸ useAction<Action>(action): ReactAction<Action> Construct a new ReactAction. Action objects can be called like functions to request execution of the corresponding Convex function. The value returned by this hook is stable across renders, so it can be used by React dependency arrays and memoization logic relying on object identity without causing rerenders. Throws an error if not used under ConvexProvider. Type parameters​ NameTypeActionextends FunctionReference<"action"> Parameters​ NameTypeDescriptionactionActionA FunctionReference for the public action to run like api.dir1.dir2.filename.func. Returns​ ReactAction<Action> The ReactAction object with that name. Defined in​ react/client.ts:754 useConvexConnectionState​ ▸ useConvexConnectionState(): ConnectionState React hook to get the current ConnectionState and subscribe to changes. This hook returns the current connection state and automatically rerenders when any part of the connection state changes (e.g., when going online/offline, when requests start/complete, etc.). The shape of ConnectionState may change in the future which may cause this hook to rerender more frequently. Throws an error if not used under ConvexProvider. Returns​ ConnectionState The current ConnectionState with the Convex backend. Defined in​ react/client.ts:793 usePreloadedQuery​ ▸ usePreloadedQuery<Query>(preloadedQuery): Query["_returnType"] Load a reactive query within a React component using a Preloaded payload from a Server Component returned by preloadQuery. This React hook contains internal state that will cause a rerender whenever the query result changes. Throws an error if not used under ConvexProvider. Type parameters​ NameTypeQueryextends FunctionReference<"query"> Parameters​ NameTypeDescriptionpreloadedQueryPreloaded<Query>The Preloaded query payload from a Server Component. Returns​ Query["_returnType"] the result of the query. Initially returns the result fetched by the Server Component. Subsequently returns the result fetched by the client. Defined in​ react/hydration.tsx:34 usePaginatedQuery​ ▸ usePaginatedQuery<Query>(query, args, options): UsePaginatedQueryReturnType<Query> Load data reactively from a paginated query to a create a growing list. This can be used to power "infinite scroll" UIs. This hook must be used with public query references that match PaginatedQueryReference. usePaginatedQuery concatenates all the pages of results into a single list and manages the continuation cursors when requesting more items. Example usage: const { results, status, isLoading, loadMore } = usePaginatedQuery( api.messages.list, { channel: "#general" }, { initialNumItems: 5 }); If the query reference or arguments change, the pagination state will be reset to the first page. Similarly, if any of the pages result in an InvalidCursor error or an error associated with too much data, the pagination state will also reset to the first page. To learn more about pagination, see Paginated Queries. Type parameters​ NameTypeQueryextends PaginatedQueryReference Parameters​ NameTypeDescriptionqueryQueryA FunctionReference to the public query function to run.args"skip" | Expand<BetterOmit<FunctionArgs<Query>, "paginationOpts">>The arguments object for the query function, excluding the paginationOpts property. That property is injected by this hook.optionsObjectAn object specifying the initialNumItems to be loaded in the first page.options.initialNumItemsnumber- Returns​ UsePaginatedQueryReturnType<Query> A UsePaginatedQueryResult that includes the currently loaded items, the status of the pagination, and a loadMore function. Defined in​ react/use_paginated_query.ts:162 resetPaginationId​ ▸ resetPaginationId(): void Reset pagination id for tests only, so tests know what it is. Returns​ void Defined in​ react/use_paginated_query.ts:458 optimisticallyUpdateValueInPaginatedQuery​ ▸ optimisticallyUpdateValueInPaginatedQuery<Query>(localStore, query, args, updateValue): void Optimistically update the values in a paginated list. This optimistic update is designed to be used to update data loaded with usePaginatedQuery. It updates the list by applying updateValue to each element of the list across all of the loaded pages. This will only apply to queries with a matching names and arguments. Example usage: const myMutation = useMutation(api.myModule.myMutation).withOptimisticUpdate((localStore, mutationArg) => { // Optimistically update the document with ID `mutationArg` // to have an additional property. optimisticallyUpdateValueInPaginatedQuery( localStore, api.myModule.paginatedQuery {}, currentValue => { if (mutationArg === currentValue._id) { return { ...currentValue, "newProperty": "newValue", }; } return currentValue; } );}); Type parameters​ NameTypeQueryextends PaginatedQueryReference Parameters​ NameTypeDescriptionlocalStoreOptimisticLocalStoreAn OptimisticLocalStore to update.queryQueryA FunctionReference for the paginated query to update.argsExpand<BetterOmit<FunctionArgs<Query>, "paginationOpts">>The arguments object to the query function, excluding the paginationOpts property.updateValue(currentValue: PaginatedQueryItem<Query>) => PaginatedQueryItem<Query>A function to produce the new values. Returns​ void Defined in​ react/use_paginated_query.ts:578 insertAtTop​ ▸ insertAtTop<Query>(options): void Updates a paginated query to insert an element at the top of the list. This is regardless of the sort order, so if the list is in descending order, the inserted element will be treated as the "biggest" element, but if it's ascending, it'll be treated as the "smallest". Example: const createTask = useMutation(api.tasks.create) .withOptimisticUpdate((localStore, mutationArgs) => { insertAtTop({ paginatedQuery: api.tasks.list, argsToMatch: { listId: mutationArgs.listId }, localQueryStore: localStore, item: { _id: crypto.randomUUID() as Id<"tasks">, title: mutationArgs.title, completed: false }, });}); Type parameters​ NameTypeQueryextends PaginatedQueryReference Parameters​ NameTypeDescriptionoptionsObject-options.paginatedQueryQueryA function reference to the paginated query.options.argsToMatch?Partial<Expand<BetterOmit<FunctionArgs<Query>, "paginationOpts">>>Optional arguments that must be in each relevant paginated query. This is useful if you use the same query function with different arguments to load different lists.options.localQueryStoreOptimisticLocalStoreoptions.itemPaginatedQueryItem<Query>The item to insert. Returns​ void Defined in​ react/use_paginated_query.ts:640 insertAtBottomIfLoaded​ ▸ insertAtBottomIfLoaded<Query>(options): void Updates a paginated query to insert an element at the bottom of the list. This is regardless of the sort order, so if the list is in descending order, the inserted element will be treated as the "smallest" element, but if it's ascending, it'll be treated as the "biggest". This only has an effect if the last page is loaded, since otherwise it would result in the element being inserted at the end of whatever is loaded (which is the middle of the list) and then popping out once the optimistic update is over. Type parameters​ NameTypeQueryextends PaginatedQueryReference Parameters​ NameTypeDescriptionoptionsObject-options.paginatedQueryQueryA function reference to the paginated query.options.argsToMatch?Partial<Expand<BetterOmit<FunctionArgs<Query>, "paginationOpts">>>Optional arguments that must be in each relevant paginated query. This is useful if you use the same query function with different arguments to load different lists.options.localQueryStoreOptimisticLocalStoreoptions.itemPaginatedQueryItem<Query>- Returns​ void Defined in​ react/use_paginated_query.ts:689 insertAtPosition​ ▸ insertAtPosition<Query>(options): void This is a helper function for inserting an item at a specific position in a paginated query. You must provide the sortOrder and a function for deriving the sort key (an array of values) from an item in the list. This will only work if the server query uses the same sort order and sort key as the optimistic update. Example: const createTask = useMutation(api.tasks.create) .withOptimisticUpdate((localStore, mutationArgs) => { insertAtPosition({ paginatedQuery: api.tasks.listByPriority, argsToMatch: { listId: mutationArgs.listId }, sortOrder: "asc", sortKeyFromItem: (item) => [item.priority, item._creationTime], localQueryStore: localStore, item: { _id: crypto.randomUUID() as Id<"tasks">, _creationTime: Date.now(), title: mutationArgs.title, completed: false, priority: mutationArgs.priority, }, });}); Type parameters​ NameTypeQueryextends PaginatedQueryReference Parameters​ NameTypeDescriptionoptionsObject-options.paginatedQueryQueryA function reference to the paginated query.options.argsToMatch?Partial<Expand<BetterOmit<FunctionArgs<Query>, "paginationOpts">>>Optional arguments that must be in each relevant paginated query. This is useful if you use the same query function with different arguments to load different lists.options.sortOrder"asc" | "desc"The sort order of the paginated query ("asc" or "desc").options.sortKeyFromItem(element: PaginatedQueryItem<Query>) => Value | Value[]A function for deriving the sort key (an array of values) from an element in the list. Including a tie-breaker field like _creationTime is recommended.options.localQueryStoreOptimisticLocalStoreoptions.itemPaginatedQueryItem<Query>The item to insert. Returns​ void Defined in​ react/use_paginated_query.ts:770 useQueries​ ▸ useQueries(queries): Record<string, any | undefined | Error> Load a variable number of reactive Convex queries. useQueries is similar to useQuery but it allows loading multiple queries which can be useful for loading a dynamic number of queries without violating the rules of React hooks. This hook accepts an object whose keys are identifiers for each query and the values are objects of { query: FunctionReference, args: Record<string, Value> }. The query is a FunctionReference for the Convex query function to load, and the args are the arguments to that function. The hook returns an object that maps each identifier to the result of the query, undefined if the query is still loading, or an instance of Error if the query threw an exception. For example if you loaded a query like: const results = useQueries({ messagesInGeneral: { query: "listMessages", args: { channel: "#general" } }}); then the result would look like: { messagesInGeneral: [{ channel: "#general", body: "hello" _id: ..., _creationTime: ... }]} This React hook contains internal state that will cause a rerender whenever any of the query results change. Throws an error if not used under ConvexProvider. Parameters​ NameTypeDescriptionqueriesRequestForQueriesAn object mapping identifiers to objects of {query: string, args: Record<string, Value> } describing which query functions to fetch. Returns​ Record<string, any | undefined | Error> An object with the same keys as the input. The values are the result of the query function, undefined if it's still loading, or an Error if it threw an exception. Defined in​ react/use_queries.ts:60

```
import { ConvexReactClient } from "convex/react";// typically loaded from an environment variableconst address = "https://small-mouse-123.convex.cloud"const convex = new ConvexReactClient(address);
```

**Pattern 7:** Example usage:

```
const { results, status, isLoading, loadMore } = usePaginatedQuery(  api.messages.list,  { channel: "#general" },  { initialNumItems: 5 });
```

**Pattern 8:** Storing Users in the Convex DatabaseIf you're using Convex Auth the user information is already stored in your database. There's nothing else you need to implement. You might want to store user information directly in your Convex database, for the following reasons: Your functions need information about other users, not just about the currently logged-in user Your functions need access to information other than the fields available in the Open ID Connect JWT There are two ways you can choose from for storing user information in your database (but only the second one allows storing information not contained in the JWT): Have your app's client call a mutation that stores the information from the JWT available on ctx.auth Implement a webhook and have your identity provider call it whenever user information changes Call a mutation from the client​ Example: Convex Authentication with Clerk (optional) Users table schema​ You can define a "users" table, optionally with an index for efficient looking up the users in the database. In the examples below we will use the tokenIdentifier from the ctx.auth.getUserIdentity() to identify the user, but you could use the subject field (which is usually set to the unique user ID from your auth provider) or even email, if your authentication provider provides email verification and you have it enabled. Which field you use will determine how multiple providers interact, and how hard it will be to migrate to a different provider. convex/schema.tsusers: defineTable({ name: v.string(), tokenIdentifier: v.string(),}).index("by_token", ["tokenIdentifier"]), Mutation for storing current user​ This is an example of a mutation that stores the user's name and tokenIdentifier: convex/users.tsTSimport { mutation } from "./_generated/server";export const store = mutation({ args: {}, handler: async (ctx) => { const identity = await ctx.auth.getUserIdentity(); if (!identity) { throw new Error("Called storeUser without authentication present"); } // Check if we've already stored this identity before. // Note: If you don't want to define an index right away, you can use // ctx.db.query("users") // .filter(q => q.eq(q.field("tokenIdentifier"), identity.tokenIdentifier)) // .unique(); const user = await ctx.db .query("users") .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier), ) .unique(); if (user !== null) { // If we've seen this identity before but the name has changed, patch the value. if (user.name !== identity.name) { await ctx.db.patch(user._id, { name: identity.name }); } return user._id; } // If it's a new identity, create a new `User`. return await ctx.db.insert("users", { name: identity.name ?? "Anonymous", tokenIdentifier: identity.tokenIdentifier, }); },}); Calling the store user mutation from React​ You can call this mutation when the user logs in from a useEffect hook. After the mutation succeeds you can update local state to reflect that the user has been stored. This helper hook that does the job: src/useStoreUserEffect.tsTSimport { useUser } from "@clerk/clerk-react";import { useConvexAuth } from "convex/react";import { useEffect, useState } from "react";import { useMutation } from "convex/react";import { api } from "../convex/_generated/api";import { Id } from "../convex/_generated/dataModel";export function useStoreUserEffect() { const { isLoading, isAuthenticated } = useConvexAuth(); const { user } = useUser(); // When this state is set we know the server // has stored the user. const [userId, setUserId] = useState<Id<"users"> | null>(null); const storeUser = useMutation(api.users.store); // Call the `storeUser` mutation function to store // the current user in the `users` table and return the `Id` value. useEffect(() => { // If the user is not logged in don't do anything if (!isAuthenticated) { return; } // Store the user in the database. // Recall that `storeUser` gets the user information via the `auth` // object on the server. You don't need to pass anything manually here. async function createUser() { const id = await storeUser(); setUserId(id); } createUser(); return () => setUserId(null); // Make sure the effect reruns if the user logs in with // a different identity }, [isAuthenticated, storeUser, user?.id]); // Combine the local state with the state from context return { isLoading: isLoading || (isAuthenticated && userId === null), isAuthenticated: isAuthenticated && userId !== null, };} You can use this hook in your top-level component. If your queries need the user document to be present, make sure that you only render the components that call them after the user has been stored: src/App.tsxTSimport { SignInButton, UserButton } from "@clerk/clerk-react";import { useQuery } from "convex/react";import { api } from "../convex/_generated/api";import { useStoreUserEffect } from "./useStoreUserEffect.js";function App() { const { isLoading, isAuthenticated } = useStoreUserEffect(); return ( <main> {isLoading ? ( <>Loading...</> ) : !isAuthenticated ? ( <SignInButton /> ) : ( <> <UserButton /> <Content /> </> )} </main> );}function Content() { const messages = useQuery(api.messages.getForCurrentUser); return <div>Authenticated content: {messages?.length}</div>;}export default App; In this way the useStoreUserEffect hook replaces the useConvexAuth hook. Using the current user's document ID​ Similarly to the store user mutation, you can retrieve the current user's ID, or throw an error if the user hasn't been stored. Now that you have users stored as documents in your Convex database, you can use their IDs as foreign keys in other documents: convex/messages.tsTSimport { v } from "convex/values";import { mutation } from "./_generated/server";export const send = mutation({ args: { body: v.string() }, handler: async (ctx, args) => { const identity = await ctx.auth.getUserIdentity(); if (!identity) { throw new Error("Unauthenticated call to mutation"); } const user = await ctx.db .query("users") .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier), ) .unique(); if (!user) { throw new Error("Unauthenticated call to mutation"); } await ctx.db.insert("messages", { body: args.body, user: user._id }); },}); // do something with `user`...}}); Loading users by their ID​ The information about other users can be retrieved via their IDs: convex/messages.tsTSimport { query } from "./_generated/server";export const list = query({ args: {}, handler: async (ctx) => { const messages = await ctx.db.query("messages").collect(); return Promise.all( messages.map(async (message) => { // For each message in this channel, fetch the `User` who wrote it and // insert their name into the `author` field. const user = await ctx.db.get(message.user); return { author: user?.name ?? "Anonymous", ...message, }; }), ); },}); Set up webhooks​ This guide will use Clerk, but Auth0 can be set up similarly via Auth0 Actions. With this implementation Clerk will call your Convex backend via an HTTP endpoint any time a user signs up, updates or deletes their account. Example: Convex Authentication with Clerk and Webhooks Configure the webhook endpoint in Clerk​ On your Clerk dashboard, go to Webhooks, click on + Add Endpoint. Set Endpoint URL to https://<your deployment name>.convex.site/clerk-users-webhook (note the domain ends in .site, not .cloud). You can see your deployment name in the .env.local file in your project directory, or on your Convex dashboard as part of the Deployment URL. For example, the endpoint URL could be: https://happy-horse-123.convex.site/clerk-users-webhook. In Message Filtering, select user for all user events (scroll down or use the search input). Click on Create. After the endpoint is saved, copy the Signing Secret (on the right side of the UI), it should start with whsec_. Set it as the value of the CLERK_WEBHOOK_SECRET environment variable in your Convex dashboard. (optional) Users table schema​ You can define a "users" table, optionally with an index for efficient looking up the users in the database. In the examples below we will use the subject from the ctx.auth.getUserIdentity() to identify the user, which should be set to the Clerk user ID. convex/schema.tsusers: defineTable({ name: v.string(), // this the Clerk ID, stored in the subject JWT field externalId: v.string(),}).index("byExternalId", ["externalId"]), Mutations for upserting and deleting users​ This is an example of mutations that handle the updates received via the webhook: convex/users.tsTSimport { internalMutation, query, QueryCtx } from "./_generated/server";import { UserJSON } from "@clerk/backend";import { v, Validator } from "convex/values";export const current = query({ args: {}, handler: async (ctx) => { return await getCurrentUser(ctx); },});export const upsertFromClerk = internalMutation({ args: { data: v.any() as Validator<UserJSON> }, // no runtime validation, trust Clerk async handler(ctx, { data }) { const userAttributes = { name: `${data.first_name} ${data.last_name}`, externalId: data.id, }; const user = await userByExternalId(ctx, data.id); if (user === null) { await ctx.db.insert("users", userAttributes); } else { await ctx.db.patch(user._id, userAttributes); } },});export const deleteFromClerk = internalMutation({ args: { clerkUserId: v.string() }, async handler(ctx, { clerkUserId }) { const user = await userByExternalId(ctx, clerkUserId); if (user !== null) { await ctx.db.delete(user._id); } else { console.warn( `Can't delete user, there is none for Clerk user ID: ${clerkUserId}`, ); } },});export async function getCurrentUserOrThrow(ctx: QueryCtx) { const userRecord = await getCurrentUser(ctx); if (!userRecord) throw new Error("Can't get current user"); return userRecord;}export async function getCurrentUser(ctx: QueryCtx) { const identity = await ctx.auth.getUserIdentity(); if (identity === null) { return null; } return await userByExternalId(ctx, identity.subject);}async function userByExternalId(ctx: QueryCtx, externalId: string) { return await ctx.db .query("users") .withIndex("byExternalId", (q) => q.eq("externalId", externalId)) .unique();} There are also a few helpers in this file: current exposes the user information to the client, which will helps the client determine whether the webhook already succeeded upsertFromClerk will be called when a user signs up or when they update their account deleteFromClerk will be called when a user deletes their account via Clerk UI from your app getCurrentUserOrThrow retrieves the currently logged-in user or throws an error getCurrentUser retrieves the currently logged-in user or returns null userByExternalId retrieves a user given the Clerk ID, and is used only for retrieving the current user or when updating an existing user via the webhook Webhook endpoint implementation​ This how the actual HTTP endpoint can be implemented: convex/http.tsTSimport { httpRouter } from "convex/server";import { httpAction } from "./_generated/server";import { internal } from "./_generated/api";import type { WebhookEvent } from "@clerk/backend";import { Webhook } from "svix";const http = httpRouter();http.route({ path: "/clerk-users-webhook", method: "POST", handler: httpAction(async (ctx, request) => { const event = await validateRequest(request); if (!event) { return new Response("Error occured", { status: 400 }); } switch (event.type) { case "user.created": // intentional fallthrough case "user.updated": await ctx.runMutation(internal.users.upsertFromClerk, { data: event.data, }); break; case "user.deleted": { const clerkUserId = event.data.id!; await ctx.runMutation(internal.users.deleteFromClerk, { clerkUserId }); break; } default: console.log("Ignored Clerk webhook event", event.type); } return new Response(null, { status: 200 }); }),});async function validateRequest(req: Request): Promise<WebhookEvent | null> { const payloadString = await req.text(); const svixHeaders = { "svix-id": req.headers.get("svix-id")!, "svix-timestamp": req.headers.get("svix-timestamp")!, "svix-signature": req.headers.get("svix-signature")!, }; const wh = new Webhook(process.env.CLERK_WEBHOOK_SECRET!); try { return wh.verify(payloadString, svixHeaders) as unknown as WebhookEvent; } catch (error) { console.error("Error verifying webhook event", error); return null; }}export default http; If you deploy your code now and sign in, you should see the user being created in your Convex database. Using the current user's document​ You can use the helpers defined before to retrieve the current user's document. Now that you have users stored as documents in your Convex database, you can use their IDs as foreign keys in other documents: convex/messages.tsTSimport { v } from "convex/values";import { mutation } from "./_generated/server";import { getCurrentUserOrThrow } from "./users";export const send = mutation({ args: { body: v.string() }, handler: async (ctx, args) => { const user = await getCurrentUserOrThrow(ctx); await ctx.db.insert("messages", { body: args.body, userId: user._id }); },}); Loading users by their ID​ The information about other users can be retrieved via their IDs: convex/messages.tsTSexport const list = query({ args: {}, handler: async (ctx) => { const messages = await ctx.db.query("messages").collect(); return Promise.all( messages.map(async (message) => { // For each message in this channel, fetch the `User` who wrote it and // insert their name into the `author` field. const user = await ctx.db.get(message.user); return { author: user?.name ?? "Anonymous", ...message, }; }), ); },}); Waiting for current user to be stored​ If you want to use the current user's document in a query, make sure that the user has already been stored. You can do this by explicitly checking for this condition before rendering the components that call the query, or before redirecting to the authenticated portion of your app. For example you can define a hook that determines the current authentication state of the client, taking into account whether the current user has been stored: src/useCurrentUser.tsTSimport { useConvexAuth, useQuery } from "convex/react";import { api } from "../convex/_generated/api";export function useCurrentUser() { const { isLoading, isAuthenticated } = useConvexAuth(); const user = useQuery(api.users.current); // Combine the authentication state with the user existence check return { isLoading: isLoading || (isAuthenticated && user === null), isAuthenticated: isAuthenticated && user !== null, };} And then you can use it to render the appropriate components: src/App.tsxTSimport { useCurrentUser } from "./useCurrentUser";export default function App() { const { isLoading, isAuthenticated } = useCurrentUser(); return ( <main> {isLoading ? ( <>Loading...</> ) : isAuthenticated ? ( <Content /> ) : ( <LoginPage /> )} </main> );}

```
ctx.auth
```

### Example Code Patterns

**Example 1** (swift):
```swift
import ConvexMobilelet convex = ConvexClient(deploymentUrl: "https://<your domain here>.convex.cloud")
```

**Example 2** (ts):
```ts
import { query } from "./_generated/server";export const listTasks = query({  handler: async (ctx) => {    const tasks = await ctx.db.query("tasks").collect();    // do something with `tasks`  },});
```

**Example 3** (ts):
```ts
if (args.a === null) {  args.a = undefined;}await ctx.db.patch(id, args);
```

**Example 4** (sh):
```sh
npx convex export --path ~/Downloads
```

**Example 5** (json):
```json
{  "_topic": "_console",  "_timestamp": 1695066350531,  "_functionType": "query",  "_functionPath": "myDir/myFile",  "_functionCached": true,  "message": "[LOG] 'My log message'"}
```

## Reference Files

This skill includes comprehensive documentation in `references/`:

- **api.md** - Api documentation
- **client.md** - Client documentation
- **database.md** - Database documentation
- **llms-txt.md** - Llms-Txt documentation
- **other.md** - Other documentation
- **production.md** - Production documentation
- **quickstart.md** - Quickstart documentation
- **tutorials.md** - Tutorials documentation

Use `view` to read specific reference files when detailed information is needed.

## Working with This Skill

### For Beginners
Start with the getting_started or tutorials reference files for foundational concepts.

### For Specific Features
Use the appropriate category reference file (api, guides, etc.) for detailed information.

### For Code Examples
The quick reference section above contains common patterns extracted from the official docs.

## Resources

### references/
Organized documentation extracted from official sources. These files contain:
- Detailed explanations
- Code examples with language annotations
- Links to original documentation
- Table of contents for quick navigation

### scripts/
Add helper scripts here for common automation tasks.

### assets/
Add templates, boilerplate, or example projects here.

## Notes

- This skill was automatically generated from official documentation
- Reference files preserve the structure and examples from source docs
- Code examples include language detection for better syntax highlighting
- Quick reference patterns are extracted from common usage examples in the docs

## Updating

To refresh this skill with updated documentation:
1. Re-run the scraper with the same configuration
2. The skill will be rebuilt with the latest information
